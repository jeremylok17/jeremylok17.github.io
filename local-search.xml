<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>转：自嘲做题家的人们，又有几个天生爱做题呢？</title>
    <link href="/2022/07/10/%E8%BD%AC%EF%BC%9A%E8%87%AA%E5%98%B2%E5%81%9A%E9%A2%98%E5%AE%B6%E7%9A%84%E4%BA%BA%E4%BB%AC%EF%BC%8C%E5%8F%88%E6%9C%89%E5%87%A0%E4%B8%AA%E5%A4%A9%E7%94%9F%E7%88%B1%E5%81%9A%E9%A2%98%E5%91%A2%EF%BC%9F/"/>
    <url>/2022/07/10/%E8%BD%AC%EF%BC%9A%E8%87%AA%E5%98%B2%E5%81%9A%E9%A2%98%E5%AE%B6%E7%9A%84%E4%BA%BA%E4%BB%AC%EF%BC%8C%E5%8F%88%E6%9C%89%E5%87%A0%E4%B8%AA%E5%A4%A9%E7%94%9F%E7%88%B1%E5%81%9A%E9%A2%98%E5%91%A2%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="自嘲做题家的人们，又有几个天生爱做题呢？-张佳玮"><a href="#自嘲做题家的人们，又有几个天生爱做题呢？-张佳玮" class="headerlink" title="自嘲做题家的人们，又有几个天生爱做题呢？ - 张佳玮"></a>自嘲做题家的人们，又有几个天生爱做题呢？ - 张佳玮</h1><p>自嘲为做题家的人们，应该相当多数，并不是天生爱做题。</p><p>就像自嘲为社畜的人们，估计没几个人，生来就想当畜。</p><p>大概，许多后来自嘲为做题家的人，都有过五花八门的爱好吧？</p><p>那些爱好是怎么慢慢消失，被刷题给淹没的呢？</p><p>我小学时，上课下课两点一线，其他时间，看看书打打游戏，骑车去租书摊看书，罢了。一个红白fc任天堂，一台手动换频道（没有遥控器）的老电视机。那会儿fc游戏卡很贵，游戏卡只能跟朋友换；书也不便宜，我自己期中期末考试考了双百（语文数学），爸妈才给买一套书——我的四大名著和金庸全集，就这么来的。</p><p>邻居家有孩子，有钢琴，有世嘉游戏机，到了1990年代中期，还有PC——于是他能打《三国志5》和《仙剑奇侠传》——还有原版的漫画杂志，载着日语版《足球小将》的世青篇。</p><p>那时我便懂了：人与人所处的环境，是不同的。</p><p>我小学将毕业时，大家都想考当时无锡第一的私立初中。都说那地方要求极高，还得会奥数。我同级的许多孩子，家里请了老师来教。我当然请不起。</p><p>骑车去新华书店，买了几本奥数书回来，自己琢磨。</p><p>我们小学后来考进那个初中的，两个孩子，我是其中之一。另外三个孩子，每人家里花了三万——那是1996年的三万。我们学校附近那一片十个小学，也就十五个孩子考进了那个初中。</p><p>我爸妈自然高兴，到处跟人说：省了三万块钱哪！</p><p>进了初中后，我才知道，无锡另两个极优秀的小学，几乎是整班整班地考进这个初中；他们学过的许多内容，我听都没听过。当然，还有些是家里花了三万进来的——那会儿我爸妈可能都没见过这么大一笔钱。</p><p>人与人所处的环境，是不同的。</p><p>我上了大学，人到了上海——但到现在，还偶尔梦见自己在高三的课堂上，说快高考了，还有一整本书没学——发现上海本地同学，也与其他地方来的同学不同。其他地方来的同学，住校、上课、考试、积极找实习机会，以求将来留在上海；上海同学，普遍潇洒得多，偶尔回家，上课也写意；找工作找实习也不用着急；毕竟对外地同学而言孜孜以求的“留在上海”，对他们而言，不太成问题吧。</p><p>人与人所处的环境，是不同的。</p><p>我后来自己写字攒钱到了巴黎读书时，29岁了，遇到各色不同的人。有年少出来读书、且读且玩、房子租在香街旁边，窗口望得见铁塔的，说起来也轻松，“男朋友在德国读书，所以顺便来读个学位，也好假期去看看他”；有在歌剧院驻唱，到巴黎来读书玩的意大利姑娘；有作品赫然的委内瑞拉建筑师，也有跟我差不多岁数，工作许久的画师，因为性取向不被家里认可，于是攒钱跑出来读书的。</p><p>我记得，比如上课午休时间，我忙里偷闲，找个地方坐下，打开笔记本写稿子，身旁那个大龄画师，也正在肝画稿；俩人抬头看看，相视一笑，继续干活；其他相对年轻的、不太用考虑谋生的同学，就能优雅地喝咖啡闲聊天，讨论一会儿去勒蓬马歇还是春天。</p><p>人与人所处的环境，是不同的。</p><p>我有位写东西的朋友，大概每隔七八年出一本书；2009年和2017年各见了我一次，优雅地对我说：别急吼吼写那么多东西呀，应该慢慢写；你这样规律的生活作息太健康了，写出来的东西也缺少刺激性……</p><p>她是一片好意，所以我也没法对她说：您先生家门豪富，您可以慢悠悠地写着玩，体验各色生活；我可是手停口停，没得挑，不写东西，就过不了日子的呢……</p><p>人与人所处的环境，是不同的。</p><p>人与人应该平等。这是应然。</p><p>人与人生来不平等。这是实然。</p><p>我觉得，人应该朝应然努力，但接受实然。</p><p>我不算什么勤苦努力学业有成之人，但多少也算见过世间的参差。</p><p>大概如果有得选，我也不介意过过小时候有明师指点、有钢琴可弹、有原版漫画可看、不用琢磨前途、不用在意是否可以留在大城市、在小小年纪就能读书见见世面、不用担心经济可以自己琢磨艺术的人生。</p><p>推己及人：</p><p>许多自嘲为做题家的努力者们，一定也有过五彩斑斓的爱好，一定也想过可以不靠刷题，而去做些喜欢的事。</p><p>但他们选择范围有限，于是继续努力刷题，相信这能改变他们的生活。</p><p>如果将刷题的时间、焦虑的时间、谋生的时间用来做些别的，他们一定能做出许多了不起的事来。</p><p>但终于还是得，自嘲为做题家。这个自嘲词，其中满是悲凉。</p><p>许多人是深知刷题本身的虚无，并不以此为傲；也知道刷题不是目的而是手段。</p><p>成为做题家的人，又有几个不是无奈至此的呢？</p><p>无可奈何到最后，就只好用“做题家”三字来自嘲。</p><p>人为什么会自嘲呢？</p><p>自嘲的话题，多是心中的疮疤。自嘲是一种自我保护的方式。</p><p>许多人自嘲，是盼着自嘲得久了，就能麻木一点，能面对现世的残酷。</p><p>每个自嘲做题家的努力者，或多或少，都是陶尽门前土的陶者，指望有一栋自己的房子；都是看着野田禾稻半枯焦的农夫，指望有一点收成。</p><p>靠着一点点自嘲，来让自己那艰苦的努力，得到一点点平衡。</p><p>所以，如果有谁，拿“做题家”三个字嘲讽人，那并不只是简单的用错词；并不是说出类似于“你的寒舍”、“让你蓬荜生辉”、“你的拙荆”之类的用词不当。</p><p>而是傲慢又残忍的攻击：</p><p>那是十指不沾泥就能鳞鳞居大厦的贵人，在嘲笑陶尽门前土的陶者；是摇扇清凉的王孙，在嘲笑担心酷暑影响收成的农夫。</p><p>如果有得选，谁乐意将人生宝贵时光，用来每天刷题？</p><p>如果有得选，谁乐意自嘲做社畜？</p><p>那些有不用刷题海当社畜就能逍遥快活的，如果还用默默努力者自嘲的做题家三字，拿来嘲讽努力者们，那真是赤裸裸的居高临下，硬生生地揭疮疤。</p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>做题家</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CT伪影去除</title>
    <link href="/2022/06/28/CT%E4%BC%AA%E5%BD%B1%E5%8E%BB%E9%99%A4/"/>
    <url>/2022/06/28/CT%E4%BC%AA%E5%BD%B1%E5%8E%BB%E9%99%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="CT图像伪影"><a href="#CT图像伪影" class="headerlink" title="CT图像伪影"></a>CT图像伪影</h2><p>如果CT机性能较差，图像中的金属伪影信息就无法消除，现在高级的CT机都带有金属伪影去除功能。如下图<br><img src="/img/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE1/pic1.png"></p><h2 id="伪影去除"><a href="#伪影去除" class="headerlink" title="伪影去除"></a>伪影去除</h2><p>本项目采用了阈值分割和基于Radon变换的线性插值相结合的方法，步骤如下。</p><h3 id="阈值分割"><a href="#阈值分割" class="headerlink" title="阈值分割"></a>阈值分割</h3><p>对原始图像（图A）进行阈值分割，把金属图像分割出来，金属图像（图B），抠掉金属的图像（图C）。<br><img src="/img/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE1/pic2.png" alt="图A—原始图像"><img src="/img/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE1/pic3.png" alt="图B—金属图像"><img src="/img/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE1/pic4.png" alt="图C—原始图像抠掉金属"></p><h3 id="Radon变换"><a href="#Radon变换" class="headerlink" title="Radon变换"></a>Radon变换</h3><p>求图像A、图像B和图像C的Radon变换，得到三张正弦图，分别是图RA，图RB，图RC。<br><img src="/img/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE1/pic5.png" alt="图RA—原始图像"><img src="/img/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE1/pic6.png" alt="图RB—金属图像"><img src="/img/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE1/pic7.png" alt="图RC—原始图像抠掉金属"></p><h3 id="插值校正"><a href="#插值校正" class="headerlink" title="插值校正"></a>插值校正</h3><p>由于图RB就是造成图A伪影的原因。在图RC中去除和图RB相交的部分，此时会留下间隙，间隙使用插值算法进行校正，此时得到图R_RES。<br><img src="/img/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE1/pic8.png" alt="图R_RES——正弦图的插值校正结果"></p><h3 id="Radon逆变换"><a href="#Radon逆变换" class="headerlink" title="Radon逆变换"></a>Radon逆变换</h3><p>对图R_RES进行Radon的逆变换，得到图D，由于图D中此时缺少金属的信息，因此把图B中的金属部分加到图像D中，得到最终的金属伪影校正图F。<br><img src="/img/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE1/pic9.png" alt="图D—金属伪影校正图未加上金属"><br><img src="/img/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE1/pic10.png" alt="图F—金属伪影校正图加上金属"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Radon变换的本质是将原来的函数做了一个空间转换，即，将原来的XY平面内的点映射到AB平面上，那么原来在XY平面上的一条直线的所有的点在AB平面上都位于同一点。记录AB平面上的点的积累厚度，便可知XY平面上的线的存在性。通过阈值分割后的结果做Radon变换，然后相减，除去金属伪影产生的”原因“。<br>最近看到中科大周少华教授做的关于伪影去除的成果，mark一下：</p><ol><li>ADN: Artifact disentanglement network for unsupervised metal artifact reduction</li><li>DuDoNet: Dual domain network for CT metal artifact reduction</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] 谷建伟,张丽,陈志强,邢宇翔.CT图像中金属伪影的快速校正[J].中国体视学与图像分析,2005,10(2):108-111<br>[2] Dong B , Li J , Shen Z . X-Ray CT Image Reconstruction via Wavelet Frame Based Regularization and Radon Domain Inpainting[J]. Journal of Scientific Computing, 2013, 54(2-3):333-349.<br>[3] Zhan R ,  Dong B . CT Image Reconstruction by Spatial-Radon Domain Data-Driven Tight Frame\n, Regularization[J]. SIAM Journal on Imaging Sciences, 2016, 9(3).</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Radon变换</tag>
      
      <tag>阈值分割</tag>
      
      <tag>医学图像处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>素数筛</title>
    <link href="/2022/06/25/%E7%B4%A0%E6%95%B0%E7%AD%9B/"/>
    <url>/2022/06/25/%E7%B4%A0%E6%95%B0%E7%AD%9B/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Output the k-th prime number.</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h2><p>k≤10000</p><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h2><p>The k-th prime number.</p><h2 id="筛法"><a href="#筛法" class="headerlink" title="筛法"></a>筛法</h2><h3 id="埃式筛法"><a href="#埃式筛法" class="headerlink" title="埃式筛法"></a>埃式筛法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">10000000</span>;<br><span class="hljs-type">int</span> prime[maxn];<br><span class="hljs-type">bool</span> IsPrime[maxn] = &#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//0代表都是素数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Find_Prime</span><span class="hljs-params">()</span></span>&#123;<br>    IsPrime[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<span class="hljs-comment">//1不是素数</span><br>    <span class="hljs-type">int</span> pNum = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= maxn; i++)&#123;<br>        <span class="hljs-keyword">if</span>(!IsPrime[i])<br>            prime[pNum++] = i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i * i; j &lt;= maxn; j += i)&#123;<br>            IsPrime[j] = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> k;<br>    <span class="hljs-built_in">Find_Prime</span>();<br>    <span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;k))&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, prime[k]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="欧拉筛法"><a href="#欧拉筛法" class="headerlink" title="欧拉筛法"></a>欧拉筛法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">10000000</span>;<br><span class="hljs-type">int</span> prime[maxn];<br><span class="hljs-type">bool</span> IsPrime[maxn];<span class="hljs-comment">//0代表都是素数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Find_Prime</span><span class="hljs-params">()</span></span>&#123;<br>    IsPrime[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<span class="hljs-comment">//1不是素数</span><br>    <span class="hljs-type">int</span> pNum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= maxn; i++)&#123;<br>        <span class="hljs-keyword">if</span>(!IsPrime[i])&#123;<br>            prime[pNum++] = i;   <br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; pNum &amp;&amp; i * prime[j] &lt;= maxn; j++)&#123;<br>            IsPrime[i * prime[j]] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(i % prime[j] == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> k;<br>    <span class="hljs-built_in">Find_Prime</span>();<br>    <span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;k))&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, prime[k - <span class="hljs-number">1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>素数筛选</tag>
      
      <tag>欧拉筛法</tag>
      
      <tag>埃式筛法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最大连续子序列</title>
    <link href="/2022/06/24/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2022/06/24/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定K个整数的序列{ N1, N2, …, NK }，其任意连续子序列可表示为{ Ni, Ni+1, …, Nj }，其中 1 &lt;= i &lt;= j &lt;= K。最大连续子序列是所有连续子序列中元素和最大的一个，例如给定序列{ -2, 11, -4, 13, -5, -2 }，其最大连续子序列为{ 11, -4, 13 }，最大和为20。现在增加一个要求，即还需要输出该子序列的第一个和最后一个元素。</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h2><p>测试输入包含若干测试用例，每个测试用例占2行，第1行给出正整数K( K&lt; 10000 )，第2行给出K个整数，中间用空格分隔。当K为0时，输入结束，该用例不被处理。</p><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h2><p>对每个测试用例，在1行里输出最大和、最大连续子序列的第一个和最后一个元素，中间用空格分隔。如果最大连续子序列不唯一，则输出序号i和j最小的那个（如输入样例的第2、3组）。若所有K个元素都是负数，则定义其最大和为0，输出整个序列的首尾元素。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>输入：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">6</span><br><span class="hljs-number">-2</span> <span class="hljs-number">11</span> <span class="hljs-number">-4</span> <span class="hljs-number">13</span> <span class="hljs-number">-5</span> <span class="hljs-number">-2</span><br><span class="hljs-number">10</span><br><span class="hljs-number">-10</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">-5</span> <span class="hljs-number">-23</span> <span class="hljs-number">3</span> <span class="hljs-number">7</span> <span class="hljs-number">-21</span><br><span class="hljs-number">6</span><br><span class="hljs-number">5</span> <span class="hljs-number">-8</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">0</span><br><span class="hljs-number">1</span><br><span class="hljs-number">10</span><br><span class="hljs-number">3</span><br><span class="hljs-number">-1</span> <span class="hljs-number">-5</span> <span class="hljs-number">-2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">-1</span> <span class="hljs-number">0</span> <span class="hljs-number">-2</span><br><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">20</span> <span class="hljs-number">11</span> <span class="hljs-number">13</span><br><span class="hljs-number">10</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span><br><span class="hljs-number">10</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span><br><span class="hljs-number">10</span> <span class="hljs-number">10</span> <span class="hljs-number">10</span><br><span class="hljs-number">0</span> <span class="hljs-number">-1</span> <span class="hljs-number">-2</span><br><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="最大连续子序列和"><a href="#最大连续子序列和" class="headerlink" title="最大连续子序列和"></a>最大连续子序列和</h3><p>递推方程为 dp[i] = max(nums[i], dp[i - 1] + nums[i])。若 dp[i] = nums[i]，说明新起了一段序列；若 dp[i] = dp[i - 1] + nums[i]，说明延续了之前序列。</p><h3 id="找出下标"><a href="#找出下标" class="headerlink" title="找出下标"></a>找出下标</h3><p>如何找到开始下标：在求 dp[i] 的过程中，如果新起了一段序列，那么就说明这是一个潜在的子序列，应该把它的开始下标记录下来。然而，这个子序列并不一定是最大的，因此我们使用变量 t 临时记录该下标，如果等到最后，发现这个子序列是最大的，那才把 t 赋给 firstIndex 作为答案。</p><p>如何找到结束下标：在求 dp[i] 的过程中，如果求得的 dp[i] 把 ans 更新了（意味着该段序列最大），那么就把 i 赋值给 lastIndex 作为答案。<br><img src="/img/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%953/pic1.png"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">10005</span>;<br><br><span class="hljs-type">int</span> nums[MAXN];<br><span class="hljs-type">int</span> dp[MAXN];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n) != EOF) &#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <br>        <span class="hljs-type">bool</span> allNegative = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;nums[i]);<br>            <span class="hljs-keyword">if</span> (nums[i] &gt;= <span class="hljs-number">0</span>) &#123;<br>                allNegative = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (allNegative) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0 %d %d\n&quot;</span>, nums[<span class="hljs-number">0</span>], nums[n - <span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> ans = dp[<span class="hljs-number">0</span>], firstIndex = <span class="hljs-number">0</span>, lastIndex = <span class="hljs-number">0</span>, t = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; dp[i - <span class="hljs-number">1</span>] + nums[i]) &#123;  <span class="hljs-comment">// 新起一段序列</span><br>                dp[i] = nums[i];<br>                t = i;<br>            &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 延长之前序列</span><br>                dp[i] = dp[i - <span class="hljs-number">1</span>] + nums[i];<br>            &#125;<br>            <br>            <span class="hljs-comment">// 如果把ans更新了，才真正找到了满足题意的最大连续子序列</span><br>            <span class="hljs-keyword">if</span> (dp[i] &gt; ans) &#123;<br>                ans = dp[i];<br>                firstIndex = t;<br>                lastIndex = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d\n&quot;</span>, ans, nums[firstIndex], nums[lastIndex]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>子序列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最大子矩阵</title>
    <link href="/2022/06/24/%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5/"/>
    <url>/2022/06/24/%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>已知矩阵的大小定义为矩阵中所有元素的和。给定一个矩阵，你的任务是找到最大的非空(大小至少是1 * 1)子矩阵。 比如，如下4 * 4的矩阵 0 -2 -7 0 9 2 -6 2 -4 1 -4 1 -1 8 0 -2 的最大子矩阵是 9 2 -4 1 -1 8 这个子矩阵的大小是15。</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h2><p>输入是一个N * N的矩阵。输入的第一行给出N (0 &lt; N &lt;= 100)。 再后面的若干行中，依次（首先从左到右给出第一行的N个整数，再从左到右给出第二行的N个整数……）给出矩阵中的N2个整数，整数之间由空白字符分隔（空格或者空行）。 已知矩阵中整数的范围都在[-127, 127]。</p><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h2><p>输出最大子矩阵的大小。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>输入：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">4</span><br><span class="hljs-number">0</span> <span class="hljs-number">-2</span> <span class="hljs-number">-7</span> <span class="hljs-number">0</span><br><span class="hljs-number">9</span> <span class="hljs-number">2</span> <span class="hljs-number">-6</span> <span class="hljs-number">2</span><br><span class="hljs-number">-4</span> <span class="hljs-number">1</span> <span class="hljs-number">-4</span>  <span class="hljs-number">1</span><br><span class="hljs-number">-1</span> <span class="hljs-number">8</span>  <span class="hljs-number">0</span> <span class="hljs-number">-2</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先写两重循环枚举起点行k1到终点行k2，再写一个循环遍历每列i，将列i压缩成一个数字，它表示第i列k1~k2行的前缀和（用二维前缀和预处理），那么就变成了一个1*n的矩阵，即一个一维数组，然后求其最大子段和，同时取max即可。</p><p>时间复杂度O(n<sup>3</sup>)。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">510</span>,inf=<span class="hljs-number">1e18</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br>ll a[N][N],sum[N][N],dp[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    <span class="hljs-type">int</span> n;cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>        &#123;<br>            cin&gt;&gt;a[i][j];<br>            sum[i][j]=sum[i<span class="hljs-number">-1</span>][j]+a[i][j]; <span class="hljs-comment">// 第j列前i行的前缀和</span><br>        &#125;<br>    &#125;<br>    ll mx=-inf;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k1=<span class="hljs-number">1</span>;k1&lt;=n;k1++) <span class="hljs-comment">// 行 上端点</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k2=k1;k2&lt;=n;k2++) <span class="hljs-comment">// 行 下端点</span><br>        &#123;<br>            <span class="hljs-comment">//dp[0]=0;</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-comment">// 列</span><br>            &#123;<br>                ll tmp=sum[k2][i]-sum[k1<span class="hljs-number">-1</span>][i]; <span class="hljs-comment">// 第i列 [k1,k2]行之和</span><br>                dp[i]=<span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>]+tmp,tmp); <span class="hljs-comment">// 最大子段和求法</span><br>                mx=<span class="hljs-built_in">max</span>(mx,dp[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,mx);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>子矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pre-Post</title>
    <link href="/2022/06/23/Pre-Post/"/>
    <url>/2022/06/23/Pre-Post/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>We are all familiar with pre-order, in-order and post-order traversals of binary trees. A common problem in data structure classes is to find the pre-order traversal of a binary tree when given the in-order and post-order traversals. Alternatively, you can find the post-order traversal when given the in-order and pre-order. However, in general you cannot determine the in-order traversal of a tree when given its pre-order and post-order traversals. Consider the four binary trees below:<br><img src="/img/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%951/pic1.jpg"></p><p>All of these trees have the same pre-order and post-order traversals. This phenomenon is not restricted to binary trees, but holds for general m-ary trees as well.</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>Input will consist of multiple problem instances. Each instance will consist of a line of the form m s1 s2, indicating that the trees are m-ary trees, s1 is the pre-order traversal and s2 is the post-order traversal.All traversal strings will consist of lowercase alphabetic characters. For all input instances, 1 &lt;= m &lt;= 20 and the length of s1 and s2 will be between 1 and 26 inclusive. If the length of s1 is k (which is the same as the length of s2, of course), the first k letters of the alphabet will be used in the strings. An input line of 0 will terminate the input.</p><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h2><p>For each problem instance, you should output one line containing the number of possible trees which would result in the pre-order and post-order traversals for the instance. All output values will be within the range of a 32-bit signed integer. For each problem instance, you are guaranteed that there is at least one tree with the given pre-order and post-order traversals.</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>输入：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">2</span> abc cba<br><span class="hljs-number">2</span> abc bca<br><span class="hljs-number">10</span> abc bca<br><span class="hljs-number">13</span> abejkcfghid jkebfghicda<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">4</span><br><span class="hljs-number">1</span><br><span class="hljs-number">45</span><br><span class="hljs-number">207352860</span><br></code></pre></td></tr></table></figure><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>我们都了解二叉树的先序遍历、中序遍历和后序遍历，当知道先序遍历和中序遍历的结果时，可以唯一的确定二叉树;同样的，当知道后序遍历和中序的结果时，也可以唯一的确定二叉树。但是如果只知道先序遍历和后序遍历的结果时，二叉树就不是唯一的了，但是我们可以计算满足条件的不同二叉树的个数。同样，我们可以将问题推广到N叉树。下面我们以例题进行分析。</p><h3 id="例1：已知二叉树的先序遍历为：abc，后序遍历为：cba，求满足条件的二叉树的个数"><a href="#例1：已知二叉树的先序遍历为：abc，后序遍历为：cba，求满足条件的二叉树的个数" class="headerlink" title="例1：已知二叉树的先序遍历为：abc，后序遍历为：cba，求满足条件的二叉树的个数"></a>例1：已知二叉树的先序遍历为：abc，后序遍历为：cba，求满足条件的二叉树的个数</h3><p>分析：首先容易得出二叉树的根结点一定是a，再由剩下的先序遍历结点序列bc（第一个结点为b）和后序遍历结点序列cb（最后一个结点为b），可知结点bc共同组成根结点a的一个子树，且其中结点b一定是该子树的根结点。这个子树可以是根结点a的左子树，也可以是右子树。</p><p>所以，满足条件的二叉树的个数sum至少为2（sum=2）。又因为对于结点bc来说，c不管是其左结点还是右结点，都满足先序和后序遍历的要求。因此满足条件的二叉树的个数sum=sum2=22=4。</p><h3 id="例2：已知10叉树的先序遍历为：abc，后序遍历为：bca，求满足条件的10叉树的个数"><a href="#例2：已知10叉树的先序遍历为：abc，后序遍历为：bca，求满足条件的10叉树的个数" class="headerlink" title="例2：已知10叉树的先序遍历为：abc，后序遍历为：bca，求满足条件的10叉树的个数"></a>例2：已知10叉树的先序遍历为：abc，后序遍历为：bca，求满足条件的10叉树的个数</h3><p>分析：首先容易得出二叉树的根结点一定是a，再由剩下的先序遍历结点序列bc和后序遍历结点序列bc完全相同，可知结点bc不能组成根结点a的一个子树，结点b和c只能是根结点a的叶结点，并且结点b一定处于结点c的左边。因为是10叉树，所以根结点a可以有10个子结点，设编号为1~10，则结点b和c的编号可以是：(1,2)、(1,3)、(1,4)、(1,5)、(1,6)、(1,7)、(1,8)、(1,9)、(1,10)、(2,3)、(2,4)、……，由组合数知识可知符合条件的共有C<sup>2</sup><sub>10</sub>=45种。</p><h3 id="例3：已知13叉树的先序遍历为：abejkcfghid，后序遍历为：jkebfghicda，求满足条件的13叉树的个数"><a href="#例3：已知13叉树的先序遍历为：abejkcfghid，后序遍历为：jkebfghicda，求满足条件的13叉树的个数" class="headerlink" title="例3：已知13叉树的先序遍历为：abejkcfghid，后序遍历为：jkebfghicda，求满足条件的13叉树的个数"></a>例3：已知13叉树的先序遍历为：abejkcfghid，后序遍历为：jkebfghicda，求满足条件的13叉树的个数</h3><p>分析：首先容易得出二叉树的根结点一定是a，再由剩下的先序遍历结点序列bejkcfghid（第一个结点为b）和后序遍历结点序列jkebfghicd（最后一个结点为d），其首尾结点不一样，可知结点集合{bejkcfghid}不可能构成根结点的一个子树，也就是说，根结点a的子树至少为2个，且第1个子树的根结点必为b（由剩下的先序遍历结点序列bejkcfghid可得），再由剩下的后序遍历结点序列jkebfghicd可知，第一个子树由结点集合{jkeb}组成；而在先序遍历结点序列bejkcfghid中位于第一个子树结点集合{bejk}后的第一个结点是c，因此可推导出第二个子树的根结点必为c，再由后序遍历结点序列jkebfghicd可知其结点集合为{cfghi}；同理可得第三个子树的结点集合为{d}，因此，根结点a的有3个子树，因为是13叉树，所以这3个子树的形态有C<sub>13</sub><sup>3</sup>种组合方式。</p><ul><li>第一个子树由先序遍历结点序列bejk和后序遍历结点序列jkeb组成，设符合条件的子树数为m1；</li><li>第二个子树由先序遍历结点序列cfghi和后序遍历结点序列fghic组成，设符合条件的子树数为m2；</li><li>第三个子树由先序遍历结点序列d和后序遍历结点序列d组成，因此d为叶结点，设符合条件的子树数为1；</li></ul><p>M1和m2的值求解同样也是由先序和后序遍历求符合条件的13叉树个数的问题，按照上述思路可递归实现，得 m<sub>1</sub> = C<sub>13</sub><sup>1</sup> ∗ C<sub>13</sub><sup>2</sup> , m<sub>2</sub> = C<sub>13</sub><sup>4</sup><br> ，因此本题满足条件的13叉树的个数为：</p><center>C<sub>13</sub><sup>3</sup> * m<sub>1</sub> * m<sub>2</sub> = 207352860</center><h3 id="总结：已知n叉树的先序和后序遍历，求符合条件的n叉树的个数，解题策略为"><a href="#总结：已知n叉树的先序和后序遍历，求符合条件的n叉树的个数，解题策略为" class="headerlink" title="总结：已知n叉树的先序和后序遍历，求符合条件的n叉树的个数，解题策略为"></a>总结：已知n叉树的先序和后序遍历，求符合条件的n叉树的个数，解题策略为</h3><ul><li><p>设符合条件的n叉树的个数为sum，初值为1;</p></li><li><p>根据n叉树的先序遍历求出根结点，根结点的子树数为k（初值为0），n叉树结点个数为m；</p></li><li><p>找出先序遍历中根结点后一个结点和后序遍历中根结点前一个结点，如果这两个结点相同，则n叉树只有一个子树(k=1)，从树的形态上讲，这个子树可以是根结点的第1个子树或第2个子树……或第n个子树，因此共有C<sub>n</sub><sup>1</sup>种；</p></li><li><p>如果这两个结点不相同，则说明根结点存在多个子树；从后序遍历的第一个结点开始找与先序遍历中根结点后一个结点相同的结点，并记下位置t1，则后序遍历1~ t1之间的结点和先序遍历2~ t1+1之间的结点构成了根结点的第一个子树(k=1)；接着从后序遍历的第t1+1个结点开始找与先序遍历中第t1+2结点相同的结点，并记下位置t2，则后序遍历t1+1~ t2之间的结点和先序遍历t1+2~ t2+1之间的结点构成了根结点的第二个子树（k=2）；若t2+1&lt;m，则根结点还有其它子树，按上述方法重复查找，直到t2+1=m。则根结点的k个子树全部确定，其形状排列方式共有C<sub>n</sub><sup>k</sup>种。</p></li><li><p>若根结点的k个子树只有一个结点，则结束求解，否则对根结点的k个子树按本解题策略分别进行递归求解，求解其符合条件的子树的个数sum1、sum2、sum3……、sumk；则sum = C<sub>n</sub><sup>k</sup> * sum1 * sum2 * … * sumk </p></li></ul><p>最后，排列数的计算使用dp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; MAX; i++) &#123;<br>dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">1</span>][j];<br>&#125;<br>dp[i][i] = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffff</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 25</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> vec vector<span class="hljs-string">&lt;ll&gt;</span></span><br><br><span class="hljs-type">int</span> dp[MAX][MAX];<span class="hljs-comment">//dp[i][j]:i个里面取j个</span><br><span class="hljs-type">int</span> n; string s1, s2;<br><br><span class="hljs-function">ll <span class="hljs-title">solve</span><span class="hljs-params">(string pre, string post)</span> </span>&#123;<br>ll sum = <span class="hljs-number">1</span>, num = <span class="hljs-number">0</span>; <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>, i;<br>pre.<span class="hljs-built_in">erase</span>(pre.<span class="hljs-built_in">begin</span>());<span class="hljs-comment">//忽略根节点</span><br>post.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">//忽略根节点</span><br><span class="hljs-keyword">while</span> (k &lt; pre.<span class="hljs-built_in">length</span>()) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; post.<span class="hljs-built_in">length</span>(); i++) &#123;<br><span class="hljs-keyword">if</span> (post[i] == pre[k]) &#123;<span class="hljs-comment">//前序后序相遇，找到了一颗子树</span><br>sum *= <span class="hljs-built_in">solve</span>(pre.<span class="hljs-built_in">substr</span>(k, i - k + <span class="hljs-number">1</span>), post.<span class="hljs-built_in">substr</span>(k, i - k + <span class="hljs-number">1</span>));<br>num++; k = i + <span class="hljs-number">1</span>;<span class="hljs-comment">//更新子树数目和下一个根节点的位置</span><br><span class="hljs-keyword">break</span>; <br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> sum * dp[n][num];<span class="hljs-comment">//他的子树的的子树的组合数，乘以他的子树的组合数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; MAX; i++) &#123;<br>dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">1</span>][j];<br>&#125;<br>dp[i][i] = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">while</span> (cin &gt;&gt; n &amp;&amp; n) &#123;<br>cin &gt;&gt; s1 &gt;&gt; s2;<br>cout &lt;&lt; <span class="hljs-built_in">solve</span>(s1, s2) &lt;&lt; endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>先序遍历</tag>
      
      <tag>中序遍历</tag>
      
      <tag>后序遍历</tag>
      
      <tag>二叉树</tag>
      
      <tag>dfs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Deepmind全能选手&quot;Gato&quot;</title>
    <link href="/2022/06/21/Deepmind%E5%85%A8%E8%83%BD%E9%80%89%E6%89%8BGato/"/>
    <url>/2022/06/21/Deepmind%E5%85%A8%E8%83%BD%E9%80%89%E6%89%8BGato/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote><p>在写文章、画图之后，AI 大模型现在又同时有了打游戏的能力。不禁在想，强AI还远吗？</p></blockquote><p>如果能使用统一的序列模型就能解决所有任务，就能解决很多不必要的麻烦。近日，受大规模语言建模的启发，Deepmind用类似的方法构造了一个通用智能体<strong>Gato</strong>，它具有多模态、多任务、多具身的特点。</p><p>既然是多任务，就需要涉及到不同类型的数据，如何将这些数据“一视同仁”地作为训练数据输入到模型中呢？为了统一处理多模态数据，Deepmind将所有数据序列化为一个扁平的token序列。在此表示中，Gato会根据上下文将token组合成动作、文字、像素等信息。</p><h2 id="训练细节"><a href="#训练细节" class="headerlink" title="训练细节"></a>训练细节</h2><p>在 Gato 的训练阶段，来自不同任务和模态的数据被序列化为扁平的 token 序列，由一个类似于大型语言模型的 transformer 神经网络进行 batch 和其他处理。由于损失被 masked，Gato 只预测动作和文本目标。<br><img src="/img/Gato/pic3.jpg" alt="训练流程"><br>在部署 Gato 时，提示（如演示）被 tokenised，形成了初始序列。接着，环境产生了首个观察结果，该结果也被 tokenised 并添加到序列中。Gato 以自回归的方式对动作向量进行采样，一次只采样一个 token。</p><p>一旦包含动作向量的所有 token 都被采样（由环境的动作规范确定），动作被解码并发送给环境，然后逐步产生新的观察结果。重复这一过程。Gato 模型始终在包含 1024 个 token 的上下文环境窗口内查看之前所有的观察结果和动作。‍下图展示了将 Gato 部署为控制策略（control policy）的流程。<br><img src="/img/Gato/pic4.jpg" alt="训练流程"></p><h2 id="训练难度"><a href="#训练难度" class="headerlink" title="训练难度"></a>训练难度</h2><p>相比有 1750 亿参数的 GPT-3，Gato 要小很多，只有约 12 亿个参数。而且，其建设基础非常简洁，只依赖于一个 Transformer 架构。</p><p>研究人员在将 Gato 与另外两个分别有 7900 万、3.64 亿参数模型的所有基准任务平均分数，进行比较后发现，对于等效的令牌计数，随着规模的增加，AI 性能会显著提高。更大的 Gato 模型可以使用更多数据进行训练，并可能更好地执行各种任务。</p><p>大概这是第一个CV、NLP、RL的结合体？</p><p>see you~</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
      <tag>多模态</tag>
      
      <tag>Deepmind</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三年的蛰伏，以及迟到了七年的FMVP</title>
    <link href="/2022/06/20/first-post/"/>
    <url>/2022/06/20/first-post/</url>
    
    <content type="html"><![CDATA[<p>2022年6月17日，波士顿花园终场哨声响起，勇士又一次捧起了奥布莱恩杯，值得一提的是2015年勇士夺冠也是在6月17日。 只不过这一次库里没有用力把篮球扔向天空，当年那群意气风发的小伙子，现在已经变成定海神针般的老将，他们成为了球队老大哥、成为了丈夫、成为了父亲。</p><span id="more"></span><h2 id="遗憾"><a href="#遗憾" class="headerlink" title="遗憾"></a>遗憾</h2><p>2015年6月17日，同样客场夺冠，同样4-2结束比赛，当宣布伊戈达拉为总决赛MVP的时候，库里依然激动地为队友欢呼。那时候我在想，没事，反正核心阵容都还年轻，薪资机构也很健康，未来有的是机会。<br>后来的故事大家都知道了，16年3-1被翻盘，17、18年杜兰特加盟勇士并两连FMVP，19年克莱、杜兰特、考辛斯、鲁尼接连伤退，20年库里报销、球队摆烂，21年克莱二次重伤、怀斯曼报销，库里独木难支，在附加赛遭遇两连败，连续两年无缘季后赛。。。</p><h2 id="重来"><a href="#重来" class="headerlink" title="重来"></a>重来</h2><p>曾经的防守大闸老的老，走的走，退役的退役，没办法，库里身为老大哥只能以身作则练好防守，不管是从态度上还是行动上。于是我们可以看到本赛季的库里很少有以前着急下手的坏习惯，轻型小前锋已经无法点名他了——曾经那个球场精灵渐渐成了重剑无锋的娃娃脸肌肉男。<br>本赛季勇士队取得了联盟第三的战绩，但是库里从赛季中期开始手感一直不佳。有人发问：是不是勇士的体系成就了库里，库里是不是吃了团队的红利？ 这一切质疑随着季后赛的到来都化为云烟。<br>季后赛首轮，面对防守称不上优秀的丹佛掘金，普尔格林等队员还能在进攻端惩戒对方。但是到了次轮与灰熊队的肉搏战，人们发现，寄予众望的普尔只能一头扎进人堆等待失误或者被封盖，防守大闸格林面对对方一堆肌肉跳跳男也显得有些无力，生死时刻，勇士队还是只能指望库里。关键时刻，库里一次次的杀入内线——用速度过掉或者顶开防守人。最终勇士有惊无险地淘汰灰熊（虽然有过55分惨案）。 西决，勇士干净利落地淘汰了077带领的独行侠，双方倒是和和睦睦，似乎都提前知道结果是什么。</p><h2 id="登顶"><a href="#登顶" class="headerlink" title="登顶"></a>登顶</h2><p>如果说分区比赛是库里和勇士队其他球员互相支持，那么总决赛的前四场比赛可以称得上是库里孤独carry的代表作。面对本赛季DPOY斯玛特，防守联盟第二的凯尔特人，库里在前四场场均轰下34分左右，有质有量。即使这样，勇士也只是取得了2-2的战绩。第四场，面临扳平或者1-3的场面，库里砍下43+10，里突外投，从此以后，”关键时刻掉链子”和库里再也无关。<br>G5、G6勇士一鼓作气全都拿下，库里也终于获得了属于自己的FMVP。G6最后有一幕打动了我，比赛时间还剩下一个多回合，库里已经去底线与戴尔库里拥抱致意，因为转播角度的原因，之前我只看到了库里的背影，然后库里转过身来手撑身子、头朝下颤抖着，我看了这么多年的库里，那一刻我以为他是笑的颤抖，可等他抬起头的那一刻，我看到了他的泪水。就像情绪会沿着网线传染，我的眼眶也已湿润，明明是一支与我无关的球队，明明是一名与我素不相识的球员，因为他们的团结，因为他的坚守，我也为他们感动。</p><h2 id="关于友谊"><a href="#关于友谊" class="headerlink" title="关于友谊"></a>关于友谊</h2><p>还有一点非常有趣，比赛的最后时刻又是伊戈达拉将球从凯尔特人队员手中要来，然后送给库里。为什么要说又？2015年总决赛G6最后一刻，库里激动的将球抛向天空，苦了伊戈达拉满场追球。这可能是伊戈达拉最后一场比赛了，曾经飞天入地的小AI，如今场均只能登场1、2分钟，当个吉祥物。从此以后，库里正式成为了勇士队中年龄最大的球员。</p><center>斯蒂芬，球拿好，以后的路自己走了！</center><p><img src="/img/%E6%9D%82%E8%B0%881/pic3.png"><br><img src="/img/%E6%9D%82%E8%B0%881/pic4.png"></p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>勇士</tag>
      
      <tag>篮球</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
