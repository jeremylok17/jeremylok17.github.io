<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>geo-localization</title>
    <link href="/2022/09/08/geo-localization/"/>
    <url>/2022/09/08/geo-localization/</url>
    
    <content type="html"><![CDATA[<h2 id="问题简述"><a href="#问题简述" class="headerlink" title="问题简述"></a>问题简述</h2><p>在遥感图像I_s（较大，分辨率不高）中查找无人机图像I_d（较小，分辨率高）的位置</p><h2 id="mark几篇文章"><a href="#mark几篇文章" class="headerlink" title="mark几篇文章"></a>mark几篇文章</h2><ol><li>Berton G, Mereu R, Trivigno G, et al. Deep visual geo-localization benchmark[C]//Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition. 2022: 5396-5407.</li><li>Wang T, Zheng Z, Yan C, et al. Each part matters: Local patterns facilitate cross-view geo-localization[J]. IEEE Transactions on Circuits and Systems for Video Technology, 2021, 32(2): 867-879.（<strong>完</strong>）</li><li>Lin T Y, Cui Y, Belongie S, et al. Learning deep representations for ground-to-aerial geolocalization[C]//Proceedings of the IEEE conference on computer vision and pattern recognition. 2015: 5007-5015.</li><li>Ma J, Jiang X, Fan A, et al. Image matching from handcrafted to deep features: A survey[J]. International Journal of Computer Vision, 2021, 129(1): 23-79.</li><li>张刚. 基于深度学习的遥感图像语义分割关键技术研究[D]. 中国科学院大学 (中国科学院光电技术研究所), 2020.</li></ol><h2 id="有个介绍geo-localization的博主"><a href="#有个介绍geo-localization的博主" class="headerlink" title="有个介绍geo-localization的博主"></a>有个介绍geo-localization的博主</h2><p><a href="https://blog.csdn.net/qq_42718887?type=blog">PyBigStar</a></p><p><a href="https://blog.csdn.net/qq_42718887/article/details/114644967?spm=1001.2014.3001.5502">Geo-localization论文阅读list</a></p><h2 id="还得找一些传统方法（先放在这里吧）"><a href="#还得找一些传统方法（先放在这里吧）" class="headerlink" title="还得找一些传统方法（先放在这里吧）"></a>还得找一些传统方法（先放在这里吧）</h2><h3 id="基于区域的"><a href="#基于区域的" class="headerlink" title="基于区域的"></a>基于区域的</h3><ul><li>NCC</li><li>互相关<h3 id="基于特征的"><a href="#基于特征的" class="headerlink" title="基于特征的"></a>基于特征的</h3></li><li>还没找</li></ul>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>geo-localization</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>再见智亿康</title>
    <link href="/2022/07/29/%E5%86%8D%E8%A7%81%E6%99%BA%E4%BA%BF%E5%BA%B7/"/>
    <url>/2022/07/29/%E5%86%8D%E8%A7%81%E6%99%BA%E4%BA%BF%E5%BA%B7/</url>
    
    <content type="html"><![CDATA[<p>我来自山东，2019年高考排名为2200，报志愿的时候“冲一把”将上财计算机放在了哈工大计算机前面<br>2019年，上财分数线掉档<br>2019年，我来到了上海财经大学，在这所著名的财经院校学习计算机</p><hr><p>大一一年，我一直处于自我怀疑状态，心理总觉得后悔、懊恼和不甘，但又没有足够的勇气去复读。我开始去知乎寻找出路，用文字排解自己的焦虑</p><p>别人说，去考经济学院的数理经济实验班吧。笔试过后，经院的招生老师说，我们财大在山东省都沦落到2000名了啊？（后记：2022年，财大在河南最低分数线和南航持平）<br>别人说，去参加社团吧。面试阶段，我仍然固执地认为我是搞技术的，不屑于参加团建。一周后，被就业中心刷掉。<br>别人说，去打比赛吧。2020上半年，因为疫情我只能宅在家里。这半年我疯狂的刷题、参加比赛，百度、小米、华为的安慰奖数不胜数。下半年回学校后打了ICPC和CCPC，南京站拿了个铁牌，打着打着队友没了。</p><hr><p><img src="/img/%E6%9D%82%E8%B0%882/fig3.jpg" alt="第一年的工位"><br>2020年夏天，不知道该干什么的时候，舅舅跟我说，要是闲着的话就跟我干吧。之后我做一个伪影去除的项目做了小一年，期间想过放弃，甚至有过转行的想法，我是不是不适合做这行。</p><p>2021年夏天，经历了一年的改进后，项目正式交接，我完成了我负责的第一个项目。之后我开始看图像融合方向的论文，先是传统方法，各种小波变换；再加上点深度学习，各种Net。达到了工程的要求，之后就是发论文了。</p><p>创新点好难啊。。。这个时候，Transformer in CV正火，我真的要给SwinIR磕一个。确定了Swin Transformer为基础后，就开始尝试加各种数学算子，起码要让方法显得高大上一点。</p><p>2022年3月，论文基本上算是写完了。第一次投的是ECCV，结果由于我的失误（没有匿名，有悖于双盲），3月底就退回来了。之后又补了些实验，重新修改了一下论文，投了篇Trans，好歹流程对了。到现在已经快4个月了，希望能早点出结果，哪怕是个大修。。。</p><p>2022年7月，我参加了中科院空间应用中心的面试，因为我的科研经历，我结识了很多超级nice的老师和师兄。今天因为我的本科学校不是工科强校，面试成绩被排到后面了，他们很热心地帮我联系招生处的老师和其他老师。</p><p>今后我可能不会去舅舅的公司了，不过我会永远感谢这段经历，感谢我的舅舅在我最沉沦的时候拉了我一把，感谢师兄们对我这个小师弟的照顾。</p><p>再见智亿康，希望我们都能茁壮成长。<br><img src="/img/%E6%9D%82%E8%B0%882/fig4.jpg" alt="2020年冬，第一次体验双屏"><br><img src="/img/%E6%9D%82%E8%B0%882/fig9.jpg" alt="2020年冬，现在这些花已经被田老师的烟熏黄了"><br><img src="/img/%E6%9D%82%E8%B0%882/fig10.jpg" alt="2020年冬，公寓旁边是个学校"><br><img src="/img/%E6%9D%82%E8%B0%882/fig11.jpg" alt="2020年冬，熟悉的济南创新谷，师兄们喜欢把找不到女朋友归结为长清区太偏"><br><img src="/img/%E6%9D%82%E8%B0%882/fig5.jpg" alt="2021年夏，师兄们大多都来公司了，很热闹"><br><img src="/img/%E6%9D%82%E8%B0%882/fig7.jpg" alt="2021年夏，晚上在公司摸鱼"><br><img src="/img/%E6%9D%82%E8%B0%882/fig8.jpg" alt="2021年夏，ppt汇报都是在这里进行的"><br><img src="/img/%E6%9D%82%E8%B0%882/fig6.jpg" alt="2021年冬，最喜欢的一张工位照，在这张桌子上完成了第一篇论文"></p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>视觉导航</title>
    <link href="/2022/07/28/%E8%A7%86%E8%A7%89%E5%AF%BC%E8%88%AA/"/>
    <url>/2022/07/28/%E8%A7%86%E8%A7%89%E5%AF%BC%E8%88%AA/</url>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>视觉导航是利用传感器感知周围环境信息作为飞行器飞行依据的导航技术</p><p><a href="https://paperswithcode.com/task/visual-navigation#:~:text=Visual%20Navigation%20is%20the%20problem%20of%20navigating%20an,of%20actions%2C%20based%20on%20the%20camera%20observations%20only.">Visual Navigation</a> is the problem of navigating an agent, e.g. a mobile robot, in an environment using camera input only.<br>The agent is given a target image (an image it will see from the target position), and its goal is to move from its current position to the target by applying a sequence of actions, based on the camera observations only.</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ul><li>图像预处理</li><li>目标提取</li><li>目标追踪</li><li>数据融介</li></ul><h2 id="mark几篇文献"><a href="#mark几篇文献" class="headerlink" title="mark几篇文献"></a>mark几篇文献</h2><p>[1] P. Anderson et al., “Vision-and-Language Navigation: Interpreting Visually-Grounded Navigation Instructions in Real Environments,” 2018 IEEE/CVF Conference on Computer Vision and Pattern Recognition, Jun. 2018, doi: 10.1109/cvpr.2018.00387.</p><p>[2] Singh Chaplot, D., Salakhutdinov, R., Gupta, A., &amp; Gupta, S. (2020). Neural Topological SLAM for Visual Navigation. 2020 IEEE/CVF Conference on Computer Vision and Pattern Recognition (CVPR). <a href="https://doi.org/10.1109/cvpr42600.2020.01289">https://doi.org/10.1109/cvpr42600.2020.01289</a></p><p>[3] P. Karkus, S. Cai and D. Hsu, “Differentiable SLAM-net: Learning Particle SLAM for Visual Navigation,” 2021 IEEE/CVF Conference on Computer Vision and Pattern Recognition (CVPR), 2021, pp. 2814-2824, doi: 10.1109/CVPR46437.2021.00284.</p>]]></content>
    
    
    <categories>
      
      <category>视觉导航</category>
      
    </categories>
    
    
    <tags>
      
      <tag>视觉导航</tag>
      
      <tag>计算机视觉</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>医学图像类别总结</title>
    <link href="/2022/07/18/%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F%E7%B1%BB%E5%88%AB%E6%80%BB%E7%BB%93/"/>
    <url>/2022/07/18/%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F%E7%B1%BB%E5%88%AB%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="医学图像种类汇总"><a href="#医学图像种类汇总" class="headerlink" title="医学图像种类汇总"></a>医学图像种类汇总</h1><h2 id="1-X线检查"><a href="#1-X线检查" class="headerlink" title="1.X线检查"></a>1.X线检查</h2><ul><li>X光检查：也叫拍片子，它有很强的穿透能力，检查时就像给身体拍了一张平面影像的照片。如果遇到被遮挡的部位，底片上不会曝光，但洗片后会呈现出白色。</li><li>适用情况：X光是观察骨骼简便的检查方式，价格也相对较便宜。如果怀疑四肢、脊柱等部位出现急性外伤，伤到了骨骼，有突发急性疼痛或是难以控制的慢性疼痛，一般会优先选择X光。</li><li>缺陷：X光检查只能提供平面影像，成像也容易受衣物、首饰甚至过厚的软组织影响，一般多用于粗看骨骼健康。过量的 X 射线照射到生物机体时，可能造成生物细胞受到破坏。因此，一般情况下，孕妇、备孕人群不建议做X光，以免影响胎。</li></ul><h2 id="2-CT与PETCT"><a href="#2-CT与PETCT" class="headerlink" title="2.CT与PETCT"></a>2.CT与PETCT</h2><ul><li>CT：CT(Computed Tomography)，即电子计算机断层扫描，它是利用精确准直的X线束、γ射线、超声波等，与灵敏度极高的探测器一同围绕人体的某一部位作一个接一个的断面扫描，具有扫描时间快，图像清晰等特点，可用于多种疾病的检查；根据所采用的射线不同可分为：X射线CT（X-CT）、超声CT（UCT）以及γ射线CT（γ-CT)等。</li><li>CT诊断主要分类：平扫CT、强化CT、脑池造影CT、腹部CT、螺旋CT。(1)平扫CT一般为横断面扫描，多以听眦线为基线，依次向上或向下连续扫描。(2)强化CT扫描常用的造影剂为60%泛影葡胺，每公斤体重1.5～2.0ml，凡有过敏史及心肾功能衰竭者禁用60%泛影葡胺。(3)脑池造影CT一般经腰穿或枕大池穿刺注入非离子型造影剂或气体，使拟检查的脑池充盈。(4)作腹部CT检查时，检查前要禁食；口服稀释的碘水剂衬托脏器的轮廓；检查中患者需屏住呼吸后扫描。(5)螺旋CT扫描，可以获得比较精细和清晰的血管重建图像，即CTA，而且可以做到三维实时显示，有希望取代常规的脑血管造影。</li><li>工作原理：利用X线束对人体某部一定厚度的层面进行扫描，由探测器接收透过该层面的X线，转变为可见光后，由光电转换变为电信号，再经模拟/数字转换器（analog/digitalconverter）转为数字，输入计算机处理。图像形成的处理有如对选定层面分成若干个体积相同的长方体，称之为体素（voxel）。扫描所得信息经计算而获得每个体素的X线衰减系数或吸收系数，再排列成矩阵，即数字矩阵（digitalmatrix），数字矩阵可存贮于磁盘或光盘中。经数字/模拟转换器（digital/analogconverter）把数字矩阵中的每个数字转为由黑到白不等灰度的小方块，即像素（pixel），并按矩阵排列，即构成CT图像。所以，CT图像是重建图像。每个体素的X线吸收系数可以通过不同的数学方法算出。</li><li>图像特点：CT图像是以不同的灰度来表示，反映器官和组织对X线的吸收程度。因此，与X线图像所示的黑白影像一样，黑影表示低吸收区，即低密度区，如含气体多的肺部；白影表示高吸收区，即高密度区，如骨骼。但是CT与X线图像相比，CT的密度分辨力高，即有高的密度分辨力（density resolution）。因此，人体软组织的密度差别虽小，吸收系数虽多接近于水，也能形成对比而成像。这是CT的突出优点。所以，</li><li>主要使用范围：CT可以更好地显示由软组织构成的器官，如脑、脊髓、纵隔、肺、肝、胆、胰以及盆部器官等，尤其是占位性病变、炎症性和外伤性病变等。并在良好的解剖图像背景上显示出病变的影像。</li></ul><hr><ul><li>PETCT(派特ct):派特ct的全称为“正电子发射型计算机断层显像”（Positron Emission Computed Tomography），英文缩写PETCT或PET/CT是核医学领域比较先进的临床检查影像技术。</li><li>工作原理：PET采用正电子核素作为示踪剂，通过病灶部位对示踪剂的摄取了解病灶功能代谢状态，可以宏观的显示全身各脏器功能，代谢等病理生理特征，更容易发现病灶；(病灶：一个局限的、具有病原微生物的病变组织,就称为病灶。）</li><li>优势：CT可以精确定位病灶及显示病灶细微结构变化，PET/CT融合图像可以全面发现病灶，精确定位及判断病灶良恶性，故能早期，快速，准确，全面发现病灶。PET犹如大海中的航标，CT犹如航行图，从而能准确，迅速找到目标。</li><li>主要适用范围：PET广泛应用于临床，已成为肿瘤、冠心病和脑部疾病这三大威胁人类生命疾病诊断和指导治疗的最有效手段。</li></ul><h2 id="3-B超超声波检查"><a href="#3-B超超声波检查" class="headerlink" title="3.B超超声波检查"></a>3.B超超声波检查</h2><ul><li>B超：是利用超声波穿透人体，声波遇到人体组织时会产生反射波，反射的回声即为B超画像。这就好比挑选西瓜时，边敲边听，体会里面的情况。</li><li>适用情况：B超以强度低、频率高、对人体无损伤、无痛苦、显示方法多样而著称，尤其对人体软组织的探测和心血管脏器的血流动力学的观察有其独到之处，如：浅表肿块、血管、穿刺定位等。B超无辐射，可以用于孕妇体检，也能发现一些骨折等骨骼问题，避免X光损伤。</li><li>缺陷：B超的穿透力较弱，对含气性器官，如肺、肠等难以探测，病变较小或声阻抗差不大时，也很难在声像图上显示，如：1cm左右的肿瘤组织也不易检出，有一定的局限性。</li></ul><h2 id="4-MRI、FMRI"><a href="#4-MRI、FMRI" class="headerlink" title="4.MRI、FMRI"></a>4.MRI、FMRI</h2><ul><li><p>MRI:核磁共振（nuclear magnetic resonance,NMR）简称磁共振，核磁共振是一种物理现象。磁共振成像（MRI）是利用收集磁共振现象所产生的信号而重建图像的成像技术。</p></li><li><p>常用MRI序列概述：</p><ul><li><p>T1加权成像(T1WI)：突出组织T1纵向弛豫（从某一个状态恢复到平衡态的过程）差别。</p></li><li><p>T2加权成像(T2WI)：突出组织T2横向弛豫差别。</p></li><li><p>T1WI观察解剖好；T2WI有利于观察病变。</p></li></ul></li><li><p>优势及适用范围：磁共振可以进行横断面、冠状面、矢状面及任意断面的图像观察。相比“CT”的断层描，“MRI”能获得多方位的原生三维断面成像，比如脑和脊髓的立体图像。对于骨、关节、脊髓、盆腔脏器、前列腺、膀胱、子宫、卵巢、心脏大血管病变及心肌梗塞的诊断尤为准确。“MRI”对软组织的分辨力远非“CT”，“X线”可比，可用来观察神经、脊髓等椎管内软组织，因此用来检测和诊断中枢神经系统疾病更佳。</p></li></ul><hr><ul><li>FMRI:功能性磁共振成像（fMRI，functional magnetic resonance imaging）是一种新兴的神经影像学方式，其原理是利用磁振造影来测量神经元活动所引发之血液动力的改变。由于fMRI的非侵入性、没有辐射暴露问题与其较为广泛的应用，从1990年代开始就在脑部功能定位领域占有一席之地。目前主要是运用在研究人及动物的脑或脊髓。</li><li>适用范围：神经外科、神经内科、药理学和精神病学等领域的临床应用十分广泛，最主要用于脑部诊断。</li></ul>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>医学图像处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>转：自嘲做题家的人们，又有几个天生爱做题呢？</title>
    <link href="/2022/07/10/%E8%BD%AC%EF%BC%9A%E8%87%AA%E5%98%B2%E5%81%9A%E9%A2%98%E5%AE%B6%E7%9A%84%E4%BA%BA%E4%BB%AC%EF%BC%8C%E5%8F%88%E6%9C%89%E5%87%A0%E4%B8%AA%E5%A4%A9%E7%94%9F%E7%88%B1%E5%81%9A%E9%A2%98%E5%91%A2%EF%BC%9F/"/>
    <url>/2022/07/10/%E8%BD%AC%EF%BC%9A%E8%87%AA%E5%98%B2%E5%81%9A%E9%A2%98%E5%AE%B6%E7%9A%84%E4%BA%BA%E4%BB%AC%EF%BC%8C%E5%8F%88%E6%9C%89%E5%87%A0%E4%B8%AA%E5%A4%A9%E7%94%9F%E7%88%B1%E5%81%9A%E9%A2%98%E5%91%A2%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="自嘲做题家的人们，又有几个天生爱做题呢？-张佳玮"><a href="#自嘲做题家的人们，又有几个天生爱做题呢？-张佳玮" class="headerlink" title="自嘲做题家的人们，又有几个天生爱做题呢？ - 张佳玮"></a>自嘲做题家的人们，又有几个天生爱做题呢？ - 张佳玮</h1><p>自嘲为做题家的人们，应该相当多数，并不是天生爱做题。</p><p>就像自嘲为社畜的人们，估计没几个人，生来就想当畜。</p><p>大概，许多后来自嘲为做题家的人，都有过五花八门的爱好吧？</p><p>那些爱好是怎么慢慢消失，被刷题给淹没的呢？</p><p>我小学时，上课下课两点一线，其他时间，看看书打打游戏，骑车去租书摊看书，罢了。一个红白fc任天堂，一台手动换频道（没有遥控器）的老电视机。那会儿fc游戏卡很贵，游戏卡只能跟朋友换；书也不便宜，我自己期中期末考试考了双百（语文数学），爸妈才给买一套书——我的四大名著和金庸全集，就这么来的。</p><p>邻居家有孩子，有钢琴，有世嘉游戏机，到了1990年代中期，还有PC——于是他能打《三国志5》和《仙剑奇侠传》——还有原版的漫画杂志，载着日语版《足球小将》的世青篇。</p><p>那时我便懂了：人与人所处的环境，是不同的。</p><p>我小学将毕业时，大家都想考当时无锡第一的私立初中。都说那地方要求极高，还得会奥数。我同级的许多孩子，家里请了老师来教。我当然请不起。</p><p>骑车去新华书店，买了几本奥数书回来，自己琢磨。</p><p>我们小学后来考进那个初中的，两个孩子，我是其中之一。另外三个孩子，每人家里花了三万——那是1996年的三万。我们学校附近那一片十个小学，也就十五个孩子考进了那个初中。</p><p>我爸妈自然高兴，到处跟人说：省了三万块钱哪！</p><p>进了初中后，我才知道，无锡另两个极优秀的小学，几乎是整班整班地考进这个初中；他们学过的许多内容，我听都没听过。当然，还有些是家里花了三万进来的——那会儿我爸妈可能都没见过这么大一笔钱。</p><p>人与人所处的环境，是不同的。</p><p>我上了大学，人到了上海——但到现在，还偶尔梦见自己在高三的课堂上，说快高考了，还有一整本书没学——发现上海本地同学，也与其他地方来的同学不同。其他地方来的同学，住校、上课、考试、积极找实习机会，以求将来留在上海；上海同学，普遍潇洒得多，偶尔回家，上课也写意；找工作找实习也不用着急；毕竟对外地同学而言孜孜以求的“留在上海”，对他们而言，不太成问题吧。</p><p>人与人所处的环境，是不同的。</p><p>我后来自己写字攒钱到了巴黎读书时，29岁了，遇到各色不同的人。有年少出来读书、且读且玩、房子租在香街旁边，窗口望得见铁塔的，说起来也轻松，“男朋友在德国读书，所以顺便来读个学位，也好假期去看看他”；有在歌剧院驻唱，到巴黎来读书玩的意大利姑娘；有作品赫然的委内瑞拉建筑师，也有跟我差不多岁数，工作许久的画师，因为性取向不被家里认可，于是攒钱跑出来读书的。</p><p>我记得，比如上课午休时间，我忙里偷闲，找个地方坐下，打开笔记本写稿子，身旁那个大龄画师，也正在肝画稿；俩人抬头看看，相视一笑，继续干活；其他相对年轻的、不太用考虑谋生的同学，就能优雅地喝咖啡闲聊天，讨论一会儿去勒蓬马歇还是春天。</p><p>人与人所处的环境，是不同的。</p><p>我有位写东西的朋友，大概每隔七八年出一本书；2009年和2017年各见了我一次，优雅地对我说：别急吼吼写那么多东西呀，应该慢慢写；你这样规律的生活作息太健康了，写出来的东西也缺少刺激性……</p><p>她是一片好意，所以我也没法对她说：您先生家门豪富，您可以慢悠悠地写着玩，体验各色生活；我可是手停口停，没得挑，不写东西，就过不了日子的呢……</p><p>人与人所处的环境，是不同的。</p><p>人与人应该平等。这是应然。</p><p>人与人生来不平等。这是实然。</p><p>我觉得，人应该朝应然努力，但接受实然。</p><p>我不算什么勤苦努力学业有成之人，但多少也算见过世间的参差。</p><p>大概如果有得选，我也不介意过过小时候有明师指点、有钢琴可弹、有原版漫画可看、不用琢磨前途、不用在意是否可以留在大城市、在小小年纪就能读书见见世面、不用担心经济可以自己琢磨艺术的人生。</p><p>推己及人：</p><p>许多自嘲为做题家的努力者们，一定也有过五彩斑斓的爱好，一定也想过可以不靠刷题，而去做些喜欢的事。</p><p>但他们选择范围有限，于是继续努力刷题，相信这能改变他们的生活。</p><p>如果将刷题的时间、焦虑的时间、谋生的时间用来做些别的，他们一定能做出许多了不起的事来。</p><p>但终于还是得，自嘲为做题家。这个自嘲词，其中满是悲凉。</p><p>许多人是深知刷题本身的虚无，并不以此为傲；也知道刷题不是目的而是手段。</p><p>成为做题家的人，又有几个不是无奈至此的呢？</p><p>无可奈何到最后，就只好用“做题家”三字来自嘲。</p><p>人为什么会自嘲呢？</p><p>自嘲的话题，多是心中的疮疤。自嘲是一种自我保护的方式。</p><p>许多人自嘲，是盼着自嘲得久了，就能麻木一点，能面对现世的残酷。</p><p>每个自嘲做题家的努力者，或多或少，都是陶尽门前土的陶者，指望有一栋自己的房子；都是看着野田禾稻半枯焦的农夫，指望有一点收成。</p><p>靠着一点点自嘲，来让自己那艰苦的努力，得到一点点平衡。</p><p>所以，如果有谁，拿“做题家”三个字嘲讽人，那并不只是简单的用错词；并不是说出类似于“你的寒舍”、“让你蓬荜生辉”、“你的拙荆”之类的用词不当。</p><p>而是傲慢又残忍的攻击：</p><p>那是十指不沾泥就能鳞鳞居大厦的贵人，在嘲笑陶尽门前土的陶者；是摇扇清凉的王孙，在嘲笑担心酷暑影响收成的农夫。</p><p>如果有得选，谁乐意将人生宝贵时光，用来每天刷题？</p><p>如果有得选，谁乐意自嘲做社畜？</p><p>那些有不用刷题海当社畜就能逍遥快活的，如果还用默默努力者自嘲的做题家三字，拿来嘲讽努力者们，那真是赤裸裸的居高临下，硬生生地揭疮疤。</p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>做题家</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CT伪影去除</title>
    <link href="/2022/06/28/CT%E4%BC%AA%E5%BD%B1%E5%8E%BB%E9%99%A4/"/>
    <url>/2022/06/28/CT%E4%BC%AA%E5%BD%B1%E5%8E%BB%E9%99%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="CT图像伪影"><a href="#CT图像伪影" class="headerlink" title="CT图像伪影"></a>CT图像伪影</h2><p>如果CT机性能较差，图像中的金属伪影信息就无法消除，现在高级的CT机都带有金属伪影去除功能。如下图<br><img src="/img/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE1/pic1.png"></p><h2 id="伪影去除"><a href="#伪影去除" class="headerlink" title="伪影去除"></a>伪影去除</h2><p>本项目采用了阈值分割和基于Radon变换的线性插值相结合的方法，步骤如下。</p><h3 id="阈值分割"><a href="#阈值分割" class="headerlink" title="阈值分割"></a>阈值分割</h3><p>对原始图像（图A）进行阈值分割，把金属图像分割出来，金属图像（图B），抠掉金属的图像（图C）。<br><img src="/img/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE1/pic2.png" alt="图A—原始图像"><img src="/img/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE1/pic3.png" alt="图B—金属图像"><img src="/img/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE1/pic4.png" alt="图C—原始图像抠掉金属"></p><h3 id="Radon变换"><a href="#Radon变换" class="headerlink" title="Radon变换"></a>Radon变换</h3><p>求图像A、图像B和图像C的Radon变换，得到三张正弦图，分别是图RA，图RB，图RC。<br><img src="/img/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE1/pic5.png" alt="图RA—原始图像"><img src="/img/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE1/pic6.png" alt="图RB—金属图像"><img src="/img/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE1/pic7.png" alt="图RC—原始图像抠掉金属"></p><h3 id="插值校正"><a href="#插值校正" class="headerlink" title="插值校正"></a>插值校正</h3><p>由于图RB就是造成图A伪影的原因。在图RC中去除和图RB相交的部分，此时会留下间隙，间隙使用插值算法进行校正，此时得到图R_RES。<br><img src="/img/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE1/pic8.png" alt="图R_RES——正弦图的插值校正结果"></p><h3 id="Radon逆变换"><a href="#Radon逆变换" class="headerlink" title="Radon逆变换"></a>Radon逆变换</h3><p>对图R_RES进行Radon的逆变换，得到图D，由于图D中此时缺少金属的信息，因此把图B中的金属部分加到图像D中，得到最终的金属伪影校正图F。<br><img src="/img/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE1/pic9.png" alt="图D—金属伪影校正图未加上金属"><br><img src="/img/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE1/pic10.png" alt="图F—金属伪影校正图加上金属"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Radon变换的本质是将原来的函数做了一个空间转换，即，将原来的XY平面内的点映射到AB平面上，那么原来在XY平面上的一条直线的所有的点在AB平面上都位于同一点。记录AB平面上的点的积累厚度，便可知XY平面上的线的存在性。通过阈值分割后的结果做Radon变换，然后相减，除去金属伪影产生的”原因“。<br>最近看到中科大周少华教授做的关于伪影去除的成果，mark一下：</p><ol><li>ADN: Artifact disentanglement network for unsupervised metal artifact reduction</li><li>DuDoNet: Dual domain network for CT metal artifact reduction</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] 谷建伟,张丽,陈志强,邢宇翔.CT图像中金属伪影的快速校正[J].中国体视学与图像分析,2005,10(2):108-111<br>[2] Dong B , Li J , Shen Z . X-Ray CT Image Reconstruction via Wavelet Frame Based Regularization and Radon Domain Inpainting[J]. Journal of Scientific Computing, 2013, 54(2-3):333-349.<br>[3] Zhan R ,  Dong B . CT Image Reconstruction by Spatial-Radon Domain Data-Driven Tight Frame\n, Regularization[J]. SIAM Journal on Imaging Sciences, 2016, 9(3).</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Radon变换</tag>
      
      <tag>阈值分割</tag>
      
      <tag>医学图像处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>素数筛</title>
    <link href="/2022/06/25/%E7%B4%A0%E6%95%B0%E7%AD%9B/"/>
    <url>/2022/06/25/%E7%B4%A0%E6%95%B0%E7%AD%9B/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Output the k-th prime number.</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h2><p>k≤10000</p><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h2><p>The k-th prime number.</p><h2 id="筛法"><a href="#筛法" class="headerlink" title="筛法"></a>筛法</h2><h3 id="埃式筛法"><a href="#埃式筛法" class="headerlink" title="埃式筛法"></a>埃式筛法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">10000000</span>;<br><span class="hljs-type">int</span> prime[maxn];<br><span class="hljs-type">bool</span> IsPrime[maxn] = &#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//0代表都是素数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Find_Prime</span><span class="hljs-params">()</span></span>&#123;<br>    IsPrime[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<span class="hljs-comment">//1不是素数</span><br>    <span class="hljs-type">int</span> pNum = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= maxn; i++)&#123;<br>        <span class="hljs-keyword">if</span>(!IsPrime[i])<br>            prime[pNum++] = i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i * i; j &lt;= maxn; j += i)&#123;<br>            IsPrime[j] = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> k;<br>    <span class="hljs-built_in">Find_Prime</span>();<br>    <span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;k))&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, prime[k]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="欧拉筛法"><a href="#欧拉筛法" class="headerlink" title="欧拉筛法"></a>欧拉筛法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">10000000</span>;<br><span class="hljs-type">int</span> prime[maxn];<br><span class="hljs-type">bool</span> IsPrime[maxn];<span class="hljs-comment">//0代表都是素数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Find_Prime</span><span class="hljs-params">()</span></span>&#123;<br>    IsPrime[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<span class="hljs-comment">//1不是素数</span><br>    <span class="hljs-type">int</span> pNum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= maxn; i++)&#123;<br>        <span class="hljs-keyword">if</span>(!IsPrime[i])&#123;<br>            prime[pNum++] = i;   <br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; pNum &amp;&amp; i * prime[j] &lt;= maxn; j++)&#123;<br>            IsPrime[i * prime[j]] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(i % prime[j] == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> k;<br>    <span class="hljs-built_in">Find_Prime</span>();<br>    <span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;k))&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, prime[k - <span class="hljs-number">1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>素数筛选</tag>
      
      <tag>欧拉筛法</tag>
      
      <tag>埃式筛法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最大连续子序列</title>
    <link href="/2022/06/24/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2022/06/24/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定K个整数的序列{ N1, N2, …, NK }，其任意连续子序列可表示为{ Ni, Ni+1, …, Nj }，其中 1 &lt;= i &lt;= j &lt;= K。最大连续子序列是所有连续子序列中元素和最大的一个，例如给定序列{ -2, 11, -4, 13, -5, -2 }，其最大连续子序列为{ 11, -4, 13 }，最大和为20。现在增加一个要求，即还需要输出该子序列的第一个和最后一个元素。</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h2><p>测试输入包含若干测试用例，每个测试用例占2行，第1行给出正整数K( K&lt; 10000 )，第2行给出K个整数，中间用空格分隔。当K为0时，输入结束，该用例不被处理。</p><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h2><p>对每个测试用例，在1行里输出最大和、最大连续子序列的第一个和最后一个元素，中间用空格分隔。如果最大连续子序列不唯一，则输出序号i和j最小的那个（如输入样例的第2、3组）。若所有K个元素都是负数，则定义其最大和为0，输出整个序列的首尾元素。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>输入：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">6</span><br><span class="hljs-number">-2</span> <span class="hljs-number">11</span> <span class="hljs-number">-4</span> <span class="hljs-number">13</span> <span class="hljs-number">-5</span> <span class="hljs-number">-2</span><br><span class="hljs-number">10</span><br><span class="hljs-number">-10</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">-5</span> <span class="hljs-number">-23</span> <span class="hljs-number">3</span> <span class="hljs-number">7</span> <span class="hljs-number">-21</span><br><span class="hljs-number">6</span><br><span class="hljs-number">5</span> <span class="hljs-number">-8</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">0</span><br><span class="hljs-number">1</span><br><span class="hljs-number">10</span><br><span class="hljs-number">3</span><br><span class="hljs-number">-1</span> <span class="hljs-number">-5</span> <span class="hljs-number">-2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">-1</span> <span class="hljs-number">0</span> <span class="hljs-number">-2</span><br><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">20</span> <span class="hljs-number">11</span> <span class="hljs-number">13</span><br><span class="hljs-number">10</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span><br><span class="hljs-number">10</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span><br><span class="hljs-number">10</span> <span class="hljs-number">10</span> <span class="hljs-number">10</span><br><span class="hljs-number">0</span> <span class="hljs-number">-1</span> <span class="hljs-number">-2</span><br><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="最大连续子序列和"><a href="#最大连续子序列和" class="headerlink" title="最大连续子序列和"></a>最大连续子序列和</h3><p>递推方程为 dp[i] = max(nums[i], dp[i - 1] + nums[i])。若 dp[i] = nums[i]，说明新起了一段序列；若 dp[i] = dp[i - 1] + nums[i]，说明延续了之前序列。</p><h3 id="找出下标"><a href="#找出下标" class="headerlink" title="找出下标"></a>找出下标</h3><p>如何找到开始下标：在求 dp[i] 的过程中，如果新起了一段序列，那么就说明这是一个潜在的子序列，应该把它的开始下标记录下来。然而，这个子序列并不一定是最大的，因此我们使用变量 t 临时记录该下标，如果等到最后，发现这个子序列是最大的，那才把 t 赋给 firstIndex 作为答案。</p><p>如何找到结束下标：在求 dp[i] 的过程中，如果求得的 dp[i] 把 ans 更新了（意味着该段序列最大），那么就把 i 赋值给 lastIndex 作为答案。<br><img src="/img/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%953/pic1.png"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">10005</span>;<br><br><span class="hljs-type">int</span> nums[MAXN];<br><span class="hljs-type">int</span> dp[MAXN];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n) != EOF) &#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <br>        <span class="hljs-type">bool</span> allNegative = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;nums[i]);<br>            <span class="hljs-keyword">if</span> (nums[i] &gt;= <span class="hljs-number">0</span>) &#123;<br>                allNegative = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (allNegative) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0 %d %d\n&quot;</span>, nums[<span class="hljs-number">0</span>], nums[n - <span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> ans = dp[<span class="hljs-number">0</span>], firstIndex = <span class="hljs-number">0</span>, lastIndex = <span class="hljs-number">0</span>, t = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; dp[i - <span class="hljs-number">1</span>] + nums[i]) &#123;  <span class="hljs-comment">// 新起一段序列</span><br>                dp[i] = nums[i];<br>                t = i;<br>            &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 延长之前序列</span><br>                dp[i] = dp[i - <span class="hljs-number">1</span>] + nums[i];<br>            &#125;<br>            <br>            <span class="hljs-comment">// 如果把ans更新了，才真正找到了满足题意的最大连续子序列</span><br>            <span class="hljs-keyword">if</span> (dp[i] &gt; ans) &#123;<br>                ans = dp[i];<br>                firstIndex = t;<br>                lastIndex = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d\n&quot;</span>, ans, nums[firstIndex], nums[lastIndex]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>子序列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最大子矩阵</title>
    <link href="/2022/06/24/%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5/"/>
    <url>/2022/06/24/%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>已知矩阵的大小定义为矩阵中所有元素的和。给定一个矩阵，你的任务是找到最大的非空(大小至少是1 * 1)子矩阵。 比如，如下4 * 4的矩阵 0 -2 -7 0 9 2 -6 2 -4 1 -4 1 -1 8 0 -2 的最大子矩阵是 9 2 -4 1 -1 8 这个子矩阵的大小是15。</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h2><p>输入是一个N * N的矩阵。输入的第一行给出N (0 &lt; N &lt;= 100)。 再后面的若干行中，依次（首先从左到右给出第一行的N个整数，再从左到右给出第二行的N个整数……）给出矩阵中的N2个整数，整数之间由空白字符分隔（空格或者空行）。 已知矩阵中整数的范围都在[-127, 127]。</p><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h2><p>输出最大子矩阵的大小。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>输入：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">4</span><br><span class="hljs-number">0</span> <span class="hljs-number">-2</span> <span class="hljs-number">-7</span> <span class="hljs-number">0</span><br><span class="hljs-number">9</span> <span class="hljs-number">2</span> <span class="hljs-number">-6</span> <span class="hljs-number">2</span><br><span class="hljs-number">-4</span> <span class="hljs-number">1</span> <span class="hljs-number">-4</span>  <span class="hljs-number">1</span><br><span class="hljs-number">-1</span> <span class="hljs-number">8</span>  <span class="hljs-number">0</span> <span class="hljs-number">-2</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先写两重循环枚举起点行k1到终点行k2，再写一个循环遍历每列i，将列i压缩成一个数字，它表示第i列k1~k2行的前缀和（用二维前缀和预处理），那么就变成了一个1*n的矩阵，即一个一维数组，然后求其最大子段和，同时取max即可。</p><p>时间复杂度O(n<sup>3</sup>)。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">510</span>,inf=<span class="hljs-number">1e18</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br>ll a[N][N],sum[N][N],dp[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    <span class="hljs-type">int</span> n;cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>        &#123;<br>            cin&gt;&gt;a[i][j];<br>            sum[i][j]=sum[i<span class="hljs-number">-1</span>][j]+a[i][j]; <span class="hljs-comment">// 第j列前i行的前缀和</span><br>        &#125;<br>    &#125;<br>    ll mx=-inf;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k1=<span class="hljs-number">1</span>;k1&lt;=n;k1++) <span class="hljs-comment">// 行 上端点</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k2=k1;k2&lt;=n;k2++) <span class="hljs-comment">// 行 下端点</span><br>        &#123;<br>            <span class="hljs-comment">//dp[0]=0;</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-comment">// 列</span><br>            &#123;<br>                ll tmp=sum[k2][i]-sum[k1<span class="hljs-number">-1</span>][i]; <span class="hljs-comment">// 第i列 [k1,k2]行之和</span><br>                dp[i]=<span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>]+tmp,tmp); <span class="hljs-comment">// 最大子段和求法</span><br>                mx=<span class="hljs-built_in">max</span>(mx,dp[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,mx);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>子矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pre-Post</title>
    <link href="/2022/06/23/Pre-Post/"/>
    <url>/2022/06/23/Pre-Post/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>We are all familiar with pre-order, in-order and post-order traversals of binary trees. A common problem in data structure classes is to find the pre-order traversal of a binary tree when given the in-order and post-order traversals. Alternatively, you can find the post-order traversal when given the in-order and pre-order. However, in general you cannot determine the in-order traversal of a tree when given its pre-order and post-order traversals. Consider the four binary trees below:<br><img src="/img/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%951/pic1.jpg"></p><p>All of these trees have the same pre-order and post-order traversals. This phenomenon is not restricted to binary trees, but holds for general m-ary trees as well.</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>Input will consist of multiple problem instances. Each instance will consist of a line of the form m s1 s2, indicating that the trees are m-ary trees, s1 is the pre-order traversal and s2 is the post-order traversal.All traversal strings will consist of lowercase alphabetic characters. For all input instances, 1 &lt;= m &lt;= 20 and the length of s1 and s2 will be between 1 and 26 inclusive. If the length of s1 is k (which is the same as the length of s2, of course), the first k letters of the alphabet will be used in the strings. An input line of 0 will terminate the input.</p><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h2><p>For each problem instance, you should output one line containing the number of possible trees which would result in the pre-order and post-order traversals for the instance. All output values will be within the range of a 32-bit signed integer. For each problem instance, you are guaranteed that there is at least one tree with the given pre-order and post-order traversals.</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>输入：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">2</span> abc cba<br><span class="hljs-number">2</span> abc bca<br><span class="hljs-number">10</span> abc bca<br><span class="hljs-number">13</span> abejkcfghid jkebfghicda<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">4</span><br><span class="hljs-number">1</span><br><span class="hljs-number">45</span><br><span class="hljs-number">207352860</span><br></code></pre></td></tr></table></figure><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>我们都了解二叉树的先序遍历、中序遍历和后序遍历，当知道先序遍历和中序遍历的结果时，可以唯一的确定二叉树;同样的，当知道后序遍历和中序的结果时，也可以唯一的确定二叉树。但是如果只知道先序遍历和后序遍历的结果时，二叉树就不是唯一的了，但是我们可以计算满足条件的不同二叉树的个数。同样，我们可以将问题推广到N叉树。下面我们以例题进行分析。</p><h3 id="例1：已知二叉树的先序遍历为：abc，后序遍历为：cba，求满足条件的二叉树的个数"><a href="#例1：已知二叉树的先序遍历为：abc，后序遍历为：cba，求满足条件的二叉树的个数" class="headerlink" title="例1：已知二叉树的先序遍历为：abc，后序遍历为：cba，求满足条件的二叉树的个数"></a>例1：已知二叉树的先序遍历为：abc，后序遍历为：cba，求满足条件的二叉树的个数</h3><p>分析：首先容易得出二叉树的根结点一定是a，再由剩下的先序遍历结点序列bc（第一个结点为b）和后序遍历结点序列cb（最后一个结点为b），可知结点bc共同组成根结点a的一个子树，且其中结点b一定是该子树的根结点。这个子树可以是根结点a的左子树，也可以是右子树。</p><p>所以，满足条件的二叉树的个数sum至少为2（sum=2）。又因为对于结点bc来说，c不管是其左结点还是右结点，都满足先序和后序遍历的要求。因此满足条件的二叉树的个数sum=sum2=22=4。</p><h3 id="例2：已知10叉树的先序遍历为：abc，后序遍历为：bca，求满足条件的10叉树的个数"><a href="#例2：已知10叉树的先序遍历为：abc，后序遍历为：bca，求满足条件的10叉树的个数" class="headerlink" title="例2：已知10叉树的先序遍历为：abc，后序遍历为：bca，求满足条件的10叉树的个数"></a>例2：已知10叉树的先序遍历为：abc，后序遍历为：bca，求满足条件的10叉树的个数</h3><p>分析：首先容易得出二叉树的根结点一定是a，再由剩下的先序遍历结点序列bc和后序遍历结点序列bc完全相同，可知结点bc不能组成根结点a的一个子树，结点b和c只能是根结点a的叶结点，并且结点b一定处于结点c的左边。因为是10叉树，所以根结点a可以有10个子结点，设编号为1~10，则结点b和c的编号可以是：(1,2)、(1,3)、(1,4)、(1,5)、(1,6)、(1,7)、(1,8)、(1,9)、(1,10)、(2,3)、(2,4)、……，由组合数知识可知符合条件的共有C<sup>2</sup><sub>10</sub>=45种。</p><h3 id="例3：已知13叉树的先序遍历为：abejkcfghid，后序遍历为：jkebfghicda，求满足条件的13叉树的个数"><a href="#例3：已知13叉树的先序遍历为：abejkcfghid，后序遍历为：jkebfghicda，求满足条件的13叉树的个数" class="headerlink" title="例3：已知13叉树的先序遍历为：abejkcfghid，后序遍历为：jkebfghicda，求满足条件的13叉树的个数"></a>例3：已知13叉树的先序遍历为：abejkcfghid，后序遍历为：jkebfghicda，求满足条件的13叉树的个数</h3><p>分析：首先容易得出二叉树的根结点一定是a，再由剩下的先序遍历结点序列bejkcfghid（第一个结点为b）和后序遍历结点序列jkebfghicd（最后一个结点为d），其首尾结点不一样，可知结点集合{bejkcfghid}不可能构成根结点的一个子树，也就是说，根结点a的子树至少为2个，且第1个子树的根结点必为b（由剩下的先序遍历结点序列bejkcfghid可得），再由剩下的后序遍历结点序列jkebfghicd可知，第一个子树由结点集合{jkeb}组成；而在先序遍历结点序列bejkcfghid中位于第一个子树结点集合{bejk}后的第一个结点是c，因此可推导出第二个子树的根结点必为c，再由后序遍历结点序列jkebfghicd可知其结点集合为{cfghi}；同理可得第三个子树的结点集合为{d}，因此，根结点a的有3个子树，因为是13叉树，所以这3个子树的形态有C<sub>13</sub><sup>3</sup>种组合方式。</p><ul><li>第一个子树由先序遍历结点序列bejk和后序遍历结点序列jkeb组成，设符合条件的子树数为m1；</li><li>第二个子树由先序遍历结点序列cfghi和后序遍历结点序列fghic组成，设符合条件的子树数为m2；</li><li>第三个子树由先序遍历结点序列d和后序遍历结点序列d组成，因此d为叶结点，设符合条件的子树数为1；</li></ul><p>M1和m2的值求解同样也是由先序和后序遍历求符合条件的13叉树个数的问题，按照上述思路可递归实现，得 m<sub>1</sub> = C<sub>13</sub><sup>1</sup> ∗ C<sub>13</sub><sup>2</sup> , m<sub>2</sub> = C<sub>13</sub><sup>4</sup><br> ，因此本题满足条件的13叉树的个数为：</p><center>C<sub>13</sub><sup>3</sup> * m<sub>1</sub> * m<sub>2</sub> = 207352860</center><h3 id="总结：已知n叉树的先序和后序遍历，求符合条件的n叉树的个数，解题策略为"><a href="#总结：已知n叉树的先序和后序遍历，求符合条件的n叉树的个数，解题策略为" class="headerlink" title="总结：已知n叉树的先序和后序遍历，求符合条件的n叉树的个数，解题策略为"></a>总结：已知n叉树的先序和后序遍历，求符合条件的n叉树的个数，解题策略为</h3><ul><li><p>设符合条件的n叉树的个数为sum，初值为1;</p></li><li><p>根据n叉树的先序遍历求出根结点，根结点的子树数为k（初值为0），n叉树结点个数为m；</p></li><li><p>找出先序遍历中根结点后一个结点和后序遍历中根结点前一个结点，如果这两个结点相同，则n叉树只有一个子树(k=1)，从树的形态上讲，这个子树可以是根结点的第1个子树或第2个子树……或第n个子树，因此共有C<sub>n</sub><sup>1</sup>种；</p></li><li><p>如果这两个结点不相同，则说明根结点存在多个子树；从后序遍历的第一个结点开始找与先序遍历中根结点后一个结点相同的结点，并记下位置t1，则后序遍历1~ t1之间的结点和先序遍历2~ t1+1之间的结点构成了根结点的第一个子树(k=1)；接着从后序遍历的第t1+1个结点开始找与先序遍历中第t1+2结点相同的结点，并记下位置t2，则后序遍历t1+1~ t2之间的结点和先序遍历t1+2~ t2+1之间的结点构成了根结点的第二个子树（k=2）；若t2+1&lt;m，则根结点还有其它子树，按上述方法重复查找，直到t2+1=m。则根结点的k个子树全部确定，其形状排列方式共有C<sub>n</sub><sup>k</sup>种。</p></li><li><p>若根结点的k个子树只有一个结点，则结束求解，否则对根结点的k个子树按本解题策略分别进行递归求解，求解其符合条件的子树的个数sum1、sum2、sum3……、sumk；则sum = C<sub>n</sub><sup>k</sup> * sum1 * sum2 * … * sumk </p></li></ul><p>最后，排列数的计算使用dp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; MAX; i++) &#123;<br>dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">1</span>][j];<br>&#125;<br>dp[i][i] = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffff</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 25</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> vec vector<span class="hljs-string">&lt;ll&gt;</span></span><br><br><span class="hljs-type">int</span> dp[MAX][MAX];<span class="hljs-comment">//dp[i][j]:i个里面取j个</span><br><span class="hljs-type">int</span> n; string s1, s2;<br><br><span class="hljs-function">ll <span class="hljs-title">solve</span><span class="hljs-params">(string pre, string post)</span> </span>&#123;<br>ll sum = <span class="hljs-number">1</span>, num = <span class="hljs-number">0</span>; <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>, i;<br>pre.<span class="hljs-built_in">erase</span>(pre.<span class="hljs-built_in">begin</span>());<span class="hljs-comment">//忽略根节点</span><br>post.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">//忽略根节点</span><br><span class="hljs-keyword">while</span> (k &lt; pre.<span class="hljs-built_in">length</span>()) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; post.<span class="hljs-built_in">length</span>(); i++) &#123;<br><span class="hljs-keyword">if</span> (post[i] == pre[k]) &#123;<span class="hljs-comment">//前序后序相遇，找到了一颗子树</span><br>sum *= <span class="hljs-built_in">solve</span>(pre.<span class="hljs-built_in">substr</span>(k, i - k + <span class="hljs-number">1</span>), post.<span class="hljs-built_in">substr</span>(k, i - k + <span class="hljs-number">1</span>));<br>num++; k = i + <span class="hljs-number">1</span>;<span class="hljs-comment">//更新子树数目和下一个根节点的位置</span><br><span class="hljs-keyword">break</span>; <br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> sum * dp[n][num];<span class="hljs-comment">//他的子树的的子树的组合数，乘以他的子树的组合数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; MAX; i++) &#123;<br>dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">1</span>][j];<br>&#125;<br>dp[i][i] = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">while</span> (cin &gt;&gt; n &amp;&amp; n) &#123;<br>cin &gt;&gt; s1 &gt;&gt; s2;<br>cout &lt;&lt; <span class="hljs-built_in">solve</span>(s1, s2) &lt;&lt; endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>先序遍历</tag>
      
      <tag>中序遍历</tag>
      
      <tag>后序遍历</tag>
      
      <tag>二叉树</tag>
      
      <tag>dfs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Deepmind全能选手&quot;Gato&quot;</title>
    <link href="/2022/06/21/Deepmind%E5%85%A8%E8%83%BD%E9%80%89%E6%89%8BGato/"/>
    <url>/2022/06/21/Deepmind%E5%85%A8%E8%83%BD%E9%80%89%E6%89%8BGato/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote><p>在写文章、画图之后，AI 大模型现在又同时有了打游戏的能力。不禁在想，强AI还远吗？</p></blockquote><p>如果能使用统一的序列模型就能解决所有任务，就能解决很多不必要的麻烦。近日，受大规模语言建模的启发，Deepmind用类似的方法构造了一个通用智能体<strong>Gato</strong>，它具有多模态、多任务、多具身的特点。</p><p>既然是多任务，就需要涉及到不同类型的数据，如何将这些数据“一视同仁”地作为训练数据输入到模型中呢？为了统一处理多模态数据，Deepmind将所有数据序列化为一个扁平的token序列。在此表示中，Gato会根据上下文将token组合成动作、文字、像素等信息。</p><h2 id="训练细节"><a href="#训练细节" class="headerlink" title="训练细节"></a>训练细节</h2><p>在 Gato 的训练阶段，来自不同任务和模态的数据被序列化为扁平的 token 序列，由一个类似于大型语言模型的 transformer 神经网络进行 batch 和其他处理。由于损失被 masked，Gato 只预测动作和文本目标。<br><img src="/img/Gato/pic3.jpg" alt="训练流程"><br>在部署 Gato 时，提示（如演示）被 tokenised，形成了初始序列。接着，环境产生了首个观察结果，该结果也被 tokenised 并添加到序列中。Gato 以自回归的方式对动作向量进行采样，一次只采样一个 token。</p><p>一旦包含动作向量的所有 token 都被采样（由环境的动作规范确定），动作被解码并发送给环境，然后逐步产生新的观察结果。重复这一过程。Gato 模型始终在包含 1024 个 token 的上下文环境窗口内查看之前所有的观察结果和动作。‍下图展示了将 Gato 部署为控制策略（control policy）的流程。<br><img src="/img/Gato/pic4.jpg" alt="训练流程"></p><h2 id="训练难度"><a href="#训练难度" class="headerlink" title="训练难度"></a>训练难度</h2><p>相比有 1750 亿参数的 GPT-3，Gato 要小很多，只有约 12 亿个参数。而且，其建设基础非常简洁，只依赖于一个 Transformer 架构。</p><p>研究人员在将 Gato 与另外两个分别有 7900 万、3.64 亿参数模型的所有基准任务平均分数，进行比较后发现，对于等效的令牌计数，随着规模的增加，AI 性能会显著提高。更大的 Gato 模型可以使用更多数据进行训练，并可能更好地执行各种任务。</p><p>大概这是第一个CV、NLP、RL的结合体？</p><p>see you~</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
      <tag>多模态</tag>
      
      <tag>Deepmind</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三年的蛰伏，以及迟到了七年的FMVP</title>
    <link href="/2022/06/20/first-post/"/>
    <url>/2022/06/20/first-post/</url>
    
    <content type="html"><![CDATA[<p>2022年6月17日，波士顿花园终场哨声响起，勇士又一次捧起了奥布莱恩杯，值得一提的是2015年勇士夺冠也是在6月17日。 只不过这一次库里没有用力把篮球扔向天空，当年那群意气风发的小伙子，现在已经变成定海神针般的老将，他们成为了球队老大哥、成为了丈夫、成为了父亲。</p><span id="more"></span><h2 id="遗憾"><a href="#遗憾" class="headerlink" title="遗憾"></a>遗憾</h2><p>2015年6月17日，同样客场夺冠，同样4-2结束比赛，当宣布伊戈达拉为总决赛MVP的时候，库里依然激动地为队友欢呼。那时候我在想，没事，反正核心阵容都还年轻，薪资机构也很健康，未来有的是机会。<br>后来的故事大家都知道了，16年3-1被翻盘，17、18年杜兰特加盟勇士并两连FMVP，19年克莱、杜兰特、考辛斯、鲁尼接连伤退，20年库里报销、球队摆烂，21年克莱二次重伤、怀斯曼报销，库里独木难支，在附加赛遭遇两连败，连续两年无缘季后赛。。。</p><h2 id="重来"><a href="#重来" class="headerlink" title="重来"></a>重来</h2><p>曾经的防守大闸老的老，走的走，退役的退役，没办法，库里身为老大哥只能以身作则练好防守，不管是从态度上还是行动上。于是我们可以看到本赛季的库里很少有以前着急下手的坏习惯，轻型小前锋已经无法点名他了——曾经那个球场精灵渐渐成了重剑无锋的娃娃脸肌肉男。<br>本赛季勇士队取得了联盟第三的战绩，但是库里从赛季中期开始手感一直不佳。有人发问：是不是勇士的体系成就了库里，库里是不是吃了团队的红利？ 这一切质疑随着季后赛的到来都化为云烟。<br>季后赛首轮，面对防守称不上优秀的丹佛掘金，普尔格林等队员还能在进攻端惩戒对方。但是到了次轮与灰熊队的肉搏战，人们发现，寄予众望的普尔只能一头扎进人堆等待失误或者被封盖，防守大闸格林面对对方一堆肌肉跳跳男也显得有些无力，生死时刻，勇士队还是只能指望库里。关键时刻，库里一次次的杀入内线——用速度过掉或者顶开防守人。最终勇士有惊无险地淘汰灰熊（虽然有过55分惨案）。 西决，勇士干净利落地淘汰了077带领的独行侠，双方倒是和和睦睦，似乎都提前知道结果是什么。</p><h2 id="登顶"><a href="#登顶" class="headerlink" title="登顶"></a>登顶</h2><p>如果说分区比赛是库里和勇士队其他球员互相支持，那么总决赛的前四场比赛可以称得上是库里孤独carry的代表作。面对本赛季DPOY斯玛特，防守联盟第二的凯尔特人，库里在前四场场均轰下34分左右，有质有量。即使这样，勇士也只是取得了2-2的战绩。第四场，面临扳平或者1-3的场面，库里砍下43+10，里突外投，从此以后，”关键时刻掉链子”和库里再也无关。<br>G5、G6勇士一鼓作气全都拿下，库里也终于获得了属于自己的FMVP。G6最后有一幕打动了我，比赛时间还剩下一个多回合，库里已经去底线与戴尔库里拥抱致意，因为转播角度的原因，之前我只看到了库里的背影，然后库里转过身来手撑身子、头朝下颤抖着，我看了这么多年的库里，那一刻我以为他是笑的颤抖，可等他抬起头的那一刻，我看到了他的泪水。就像情绪会沿着网线传染，我的眼眶也已湿润，明明是一支与我无关的球队，明明是一名与我素不相识的球员，因为他们的团结，因为他的坚守，我也为他们感动。</p><h2 id="关于友谊"><a href="#关于友谊" class="headerlink" title="关于友谊"></a>关于友谊</h2><p>还有一点非常有趣，比赛的最后时刻又是伊戈达拉将球从凯尔特人队员手中要来，然后送给库里。为什么要说又？2015年总决赛G6最后一刻，库里激动的将球抛向天空，苦了伊戈达拉满场追球。这可能是伊戈达拉最后一场比赛了，曾经飞天入地的小AI，如今场均只能登场1、2分钟，当个吉祥物。从此以后，库里正式成为了勇士队中年龄最大的球员。</p><center>斯蒂芬，球拿好，以后的路自己走了！</center><p><img src="/img/%E6%9D%82%E8%B0%881/pic3.png"><br><img src="/img/%E6%9D%82%E8%B0%881/pic4.png"></p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>勇士</tag>
      
      <tag>篮球</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
