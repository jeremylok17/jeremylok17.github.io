<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>素数筛</title>
    <link href="/2022/06/25/%E7%B4%A0%E6%95%B0%E7%AD%9B/"/>
    <url>/2022/06/25/%E7%B4%A0%E6%95%B0%E7%AD%9B/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Output the k-th prime number.</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h2><p>k≤10000</p><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h2><p>The k-th prime number.</p><h2 id="筛法"><a href="#筛法" class="headerlink" title="筛法"></a>筛法</h2><h3 id="埃式筛法"><a href="#埃式筛法" class="headerlink" title="埃式筛法"></a>埃式筛法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">10000000</span>;<br><span class="hljs-type">int</span> prime[maxn];<br><span class="hljs-type">bool</span> IsPrime[maxn] = &#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//0代表都是素数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Find_Prime</span><span class="hljs-params">()</span></span>&#123;<br>    IsPrime[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<span class="hljs-comment">//1不是素数</span><br>    <span class="hljs-type">int</span> pNum = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= maxn; i++)&#123;<br>        <span class="hljs-keyword">if</span>(!IsPrime[i])<br>            prime[pNum++] = i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i * i; j &lt;= maxn; j += i)&#123;<br>            IsPrime[j] = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> k;<br>    <span class="hljs-built_in">Find_Prime</span>();<br>    <span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;k))&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, prime[k]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="欧拉筛法"><a href="#欧拉筛法" class="headerlink" title="欧拉筛法"></a>欧拉筛法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">10000000</span>;<br><span class="hljs-type">int</span> prime[maxn];<br><span class="hljs-type">bool</span> IsPrime[maxn];<span class="hljs-comment">//0代表都是素数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Find_Prime</span><span class="hljs-params">()</span></span>&#123;<br>    IsPrime[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<span class="hljs-comment">//1不是素数</span><br>    <span class="hljs-type">int</span> pNum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= maxn; i++)&#123;<br>        <span class="hljs-keyword">if</span>(!IsPrime[i])&#123;<br>            prime[pNum++] = i;   <br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; pNum &amp;&amp; i * prime[j] &lt;= maxn; j++)&#123;<br>            IsPrime[i * prime[j]] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(i % prime[j] == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> k;<br>    <span class="hljs-built_in">Find_Prime</span>();<br>    <span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;k))&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, prime[k - <span class="hljs-number">1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>素数筛选</tag>
      
      <tag>欧拉筛法</tag>
      
      <tag>埃式筛法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最大连续子序列</title>
    <link href="/2022/06/24/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2022/06/24/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定K个整数的序列{ N1, N2, …, NK }，其任意连续子序列可表示为{ Ni, Ni+1, …, Nj }，其中 1 &lt;= i &lt;= j &lt;= K。最大连续子序列是所有连续子序列中元素和最大的一个，例如给定序列{ -2, 11, -4, 13, -5, -2 }，其最大连续子序列为{ 11, -4, 13 }，最大和为20。现在增加一个要求，即还需要输出该子序列的第一个和最后一个元素。</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h2><p>测试输入包含若干测试用例，每个测试用例占2行，第1行给出正整数K( K&lt; 10000 )，第2行给出K个整数，中间用空格分隔。当K为0时，输入结束，该用例不被处理。</p><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h2><p>对每个测试用例，在1行里输出最大和、最大连续子序列的第一个和最后一个元素，中间用空格分隔。如果最大连续子序列不唯一，则输出序号i和j最小的那个（如输入样例的第2、3组）。若所有K个元素都是负数，则定义其最大和为0，输出整个序列的首尾元素。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>输入：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">6</span><br><span class="hljs-number">-2</span> <span class="hljs-number">11</span> <span class="hljs-number">-4</span> <span class="hljs-number">13</span> <span class="hljs-number">-5</span> <span class="hljs-number">-2</span><br><span class="hljs-number">10</span><br><span class="hljs-number">-10</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">-5</span> <span class="hljs-number">-23</span> <span class="hljs-number">3</span> <span class="hljs-number">7</span> <span class="hljs-number">-21</span><br><span class="hljs-number">6</span><br><span class="hljs-number">5</span> <span class="hljs-number">-8</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">0</span><br><span class="hljs-number">1</span><br><span class="hljs-number">10</span><br><span class="hljs-number">3</span><br><span class="hljs-number">-1</span> <span class="hljs-number">-5</span> <span class="hljs-number">-2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">-1</span> <span class="hljs-number">0</span> <span class="hljs-number">-2</span><br><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">20</span> <span class="hljs-number">11</span> <span class="hljs-number">13</span><br><span class="hljs-number">10</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span><br><span class="hljs-number">10</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span><br><span class="hljs-number">10</span> <span class="hljs-number">10</span> <span class="hljs-number">10</span><br><span class="hljs-number">0</span> <span class="hljs-number">-1</span> <span class="hljs-number">-2</span><br><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="最大连续子序列和"><a href="#最大连续子序列和" class="headerlink" title="最大连续子序列和"></a>最大连续子序列和</h3><p>递推方程为 dp[i] = max(nums[i], dp[i - 1] + nums[i])。若 dp[i] = nums[i]，说明新起了一段序列；若 dp[i] = dp[i - 1] + nums[i]，说明延续了之前序列。</p><h3 id="找出下标"><a href="#找出下标" class="headerlink" title="找出下标"></a>找出下标</h3><p>如何找到开始下标：在求 dp[i] 的过程中，如果新起了一段序列，那么就说明这是一个潜在的子序列，应该把它的开始下标记录下来。然而，这个子序列并不一定是最大的，因此我们使用变量 t 临时记录该下标，如果等到最后，发现这个子序列是最大的，那才把 t 赋给 firstIndex 作为答案。</p><p>如何找到结束下标：在求 dp[i] 的过程中，如果求得的 dp[i] 把 ans 更新了（意味着该段序列最大），那么就把 i 赋值给 lastIndex 作为答案。<br><img src="/img/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%953/pic1.png"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">10005</span>;<br><br><span class="hljs-type">int</span> nums[MAXN];<br><span class="hljs-type">int</span> dp[MAXN];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n) != EOF) &#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <br>        <span class="hljs-type">bool</span> allNegative = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;nums[i]);<br>            <span class="hljs-keyword">if</span> (nums[i] &gt;= <span class="hljs-number">0</span>) &#123;<br>                allNegative = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (allNegative) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0 %d %d\n&quot;</span>, nums[<span class="hljs-number">0</span>], nums[n - <span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> ans = dp[<span class="hljs-number">0</span>], firstIndex = <span class="hljs-number">0</span>, lastIndex = <span class="hljs-number">0</span>, t = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; dp[i - <span class="hljs-number">1</span>] + nums[i]) &#123;  <span class="hljs-comment">// 新起一段序列</span><br>                dp[i] = nums[i];<br>                t = i;<br>            &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 延长之前序列</span><br>                dp[i] = dp[i - <span class="hljs-number">1</span>] + nums[i];<br>            &#125;<br>            <br>            <span class="hljs-comment">// 如果把ans更新了，才真正找到了满足题意的最大连续子序列</span><br>            <span class="hljs-keyword">if</span> (dp[i] &gt; ans) &#123;<br>                ans = dp[i];<br>                firstIndex = t;<br>                lastIndex = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d\n&quot;</span>, ans, nums[firstIndex], nums[lastIndex]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>子序列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最大子矩阵</title>
    <link href="/2022/06/24/%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5/"/>
    <url>/2022/06/24/%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>已知矩阵的大小定义为矩阵中所有元素的和。给定一个矩阵，你的任务是找到最大的非空(大小至少是1 * 1)子矩阵。 比如，如下4 * 4的矩阵 0 -2 -7 0 9 2 -6 2 -4 1 -4 1 -1 8 0 -2 的最大子矩阵是 9 2 -4 1 -1 8 这个子矩阵的大小是15。</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h2><p>输入是一个N * N的矩阵。输入的第一行给出N (0 &lt; N &lt;= 100)。 再后面的若干行中，依次（首先从左到右给出第一行的N个整数，再从左到右给出第二行的N个整数……）给出矩阵中的N2个整数，整数之间由空白字符分隔（空格或者空行）。 已知矩阵中整数的范围都在[-127, 127]。</p><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h2><p>输出最大子矩阵的大小。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>输入：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">4</span><br><span class="hljs-number">0</span> <span class="hljs-number">-2</span> <span class="hljs-number">-7</span> <span class="hljs-number">0</span><br><span class="hljs-number">9</span> <span class="hljs-number">2</span> <span class="hljs-number">-6</span> <span class="hljs-number">2</span><br><span class="hljs-number">-4</span> <span class="hljs-number">1</span> <span class="hljs-number">-4</span>  <span class="hljs-number">1</span><br><span class="hljs-number">-1</span> <span class="hljs-number">8</span>  <span class="hljs-number">0</span> <span class="hljs-number">-2</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先写两重循环枚举起点行k1到终点行k2，再写一个循环遍历每列i，将列i压缩成一个数字，它表示第i列k1~k2行的前缀和（用二维前缀和预处理），那么就变成了一个1*n的矩阵，即一个一维数组，然后求其最大子段和，同时取max即可。</p><p>时间复杂度O(n<sup>3</sup>)。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">510</span>,inf=<span class="hljs-number">1e18</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br>ll a[N][N],sum[N][N],dp[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    <span class="hljs-type">int</span> n;cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>        &#123;<br>            cin&gt;&gt;a[i][j];<br>            sum[i][j]=sum[i<span class="hljs-number">-1</span>][j]+a[i][j]; <span class="hljs-comment">// 第j列前i行的前缀和</span><br>        &#125;<br>    &#125;<br>    ll mx=-inf;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k1=<span class="hljs-number">1</span>;k1&lt;=n;k1++) <span class="hljs-comment">// 行 上端点</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k2=k1;k2&lt;=n;k2++) <span class="hljs-comment">// 行 下端点</span><br>        &#123;<br>            <span class="hljs-comment">//dp[0]=0;</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-comment">// 列</span><br>            &#123;<br>                ll tmp=sum[k2][i]-sum[k1<span class="hljs-number">-1</span>][i]; <span class="hljs-comment">// 第i列 [k1,k2]行之和</span><br>                dp[i]=<span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>]+tmp,tmp); <span class="hljs-comment">// 最大子段和求法</span><br>                mx=<span class="hljs-built_in">max</span>(mx,dp[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,mx);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>子矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pre-Post</title>
    <link href="/2022/06/23/Pre-Post/"/>
    <url>/2022/06/23/Pre-Post/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>We are all familiar with pre-order, in-order and post-order traversals of binary trees. A common problem in data structure classes is to find the pre-order traversal of a binary tree when given the in-order and post-order traversals. Alternatively, you can find the post-order traversal when given the in-order and pre-order. However, in general you cannot determine the in-order traversal of a tree when given its pre-order and post-order traversals. Consider the four binary trees below:<br><img src="/img/%E7%AE%97%E6%B3%951/pic1.jpg"></p><p>All of these trees have the same pre-order and post-order traversals. This phenomenon is not restricted to binary trees, but holds for general m-ary trees as well.</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>Input will consist of multiple problem instances. Each instance will consist of a line of the form m s1 s2, indicating that the trees are m-ary trees, s1 is the pre-order traversal and s2 is the post-order traversal.All traversal strings will consist of lowercase alphabetic characters. For all input instances, 1 &lt;= m &lt;= 20 and the length of s1 and s2 will be between 1 and 26 inclusive. If the length of s1 is k (which is the same as the length of s2, of course), the first k letters of the alphabet will be used in the strings. An input line of 0 will terminate the input.</p><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h2><p>For each problem instance, you should output one line containing the number of possible trees which would result in the pre-order and post-order traversals for the instance. All output values will be within the range of a 32-bit signed integer. For each problem instance, you are guaranteed that there is at least one tree with the given pre-order and post-order traversals.</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>输入：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">2</span> abc cba<br><span class="hljs-number">2</span> abc bca<br><span class="hljs-number">10</span> abc bca<br><span class="hljs-number">13</span> abejkcfghid jkebfghicda<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">4</span><br><span class="hljs-number">1</span><br><span class="hljs-number">45</span><br><span class="hljs-number">207352860</span><br></code></pre></td></tr></table></figure><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>我们都了解二叉树的先序遍历、中序遍历和后序遍历，当知道先序遍历和中序遍历的结果时，可以唯一的确定二叉树;同样的，当知道后序遍历和中序的结果时，也可以唯一的确定二叉树。但是如果只知道先序遍历和后序遍历的结果时，二叉树就不是唯一的了，但是我们可以计算满足条件的不同二叉树的个数。同样，我们可以将问题推广到N叉树。下面我们以例题进行分析。</p><h3 id="例1：已知二叉树的先序遍历为：abc，后序遍历为：cba，求满足条件的二叉树的个数"><a href="#例1：已知二叉树的先序遍历为：abc，后序遍历为：cba，求满足条件的二叉树的个数" class="headerlink" title="例1：已知二叉树的先序遍历为：abc，后序遍历为：cba，求满足条件的二叉树的个数"></a>例1：已知二叉树的先序遍历为：abc，后序遍历为：cba，求满足条件的二叉树的个数</h3><p>分析：首先容易得出二叉树的根结点一定是a，再由剩下的先序遍历结点序列bc（第一个结点为b）和后序遍历结点序列cb（最后一个结点为b），可知结点bc共同组成根结点a的一个子树，且其中结点b一定是该子树的根结点。这个子树可以是根结点a的左子树，也可以是右子树。</p><p>所以，满足条件的二叉树的个数sum至少为2（sum=2）。又因为对于结点bc来说，c不管是其左结点还是右结点，都满足先序和后序遍历的要求。因此满足条件的二叉树的个数sum=sum2=22=4。</p><h3 id="例2：已知10叉树的先序遍历为：abc，后序遍历为：bca，求满足条件的10叉树的个数"><a href="#例2：已知10叉树的先序遍历为：abc，后序遍历为：bca，求满足条件的10叉树的个数" class="headerlink" title="例2：已知10叉树的先序遍历为：abc，后序遍历为：bca，求满足条件的10叉树的个数"></a>例2：已知10叉树的先序遍历为：abc，后序遍历为：bca，求满足条件的10叉树的个数</h3><p>分析：首先容易得出二叉树的根结点一定是a，再由剩下的先序遍历结点序列bc和后序遍历结点序列bc完全相同，可知结点bc不能组成根结点a的一个子树，结点b和c只能是根结点a的叶结点，并且结点b一定处于结点c的左边。因为是10叉树，所以根结点a可以有10个子结点，设编号为1~10，则结点b和c的编号可以是：(1,2)、(1,3)、(1,4)、(1,5)、(1,6)、(1,7)、(1,8)、(1,9)、(1,10)、(2,3)、(2,4)、……，由组合数知识可知符合条件的共有C<sup>2</sup><sub>10</sub>=45种。</p><h3 id="例3：已知13叉树的先序遍历为：abejkcfghid，后序遍历为：jkebfghicda，求满足条件的13叉树的个数"><a href="#例3：已知13叉树的先序遍历为：abejkcfghid，后序遍历为：jkebfghicda，求满足条件的13叉树的个数" class="headerlink" title="例3：已知13叉树的先序遍历为：abejkcfghid，后序遍历为：jkebfghicda，求满足条件的13叉树的个数"></a>例3：已知13叉树的先序遍历为：abejkcfghid，后序遍历为：jkebfghicda，求满足条件的13叉树的个数</h3><p>分析：首先容易得出二叉树的根结点一定是a，再由剩下的先序遍历结点序列bejkcfghid（第一个结点为b）和后序遍历结点序列jkebfghicd（最后一个结点为d），其首尾结点不一样，可知结点集合{bejkcfghid}不可能构成根结点的一个子树，也就是说，根结点a的子树至少为2个，且第1个子树的根结点必为b（由剩下的先序遍历结点序列bejkcfghid可得），再由剩下的后序遍历结点序列jkebfghicd可知，第一个子树由结点集合{jkeb}组成；而在先序遍历结点序列bejkcfghid中位于第一个子树结点集合{bejk}后的第一个结点是c，因此可推导出第二个子树的根结点必为c，再由后序遍历结点序列jkebfghicd可知其结点集合为{cfghi}；同理可得第三个子树的结点集合为{d}，因此，根结点a的有3个子树，因为是13叉树，所以这3个子树的形态有C<sub>13</sub><sup>3</sup>种组合方式。</p><ul><li>第一个子树由先序遍历结点序列bejk和后序遍历结点序列jkeb组成，设符合条件的子树数为m1；</li><li>第二个子树由先序遍历结点序列cfghi和后序遍历结点序列fghic组成，设符合条件的子树数为m2；</li><li>第三个子树由先序遍历结点序列d和后序遍历结点序列d组成，因此d为叶结点，设符合条件的子树数为1；</li></ul><p>M1和m2的值求解同样也是由先序和后序遍历求符合条件的13叉树个数的问题，按照上述思路可递归实现，得 m<sub>1</sub> = C<sub>13</sub><sup>1</sup> ∗ C<sub>13</sub><sup>2</sup> , m<sub>2</sub> = C<sub>13</sub><sup>4</sup><br> ，因此本题满足条件的13叉树的个数为：</p><center>C<sub>13</sub><sup>3</sup> * m<sub>1</sub> * m<sub>2</sub> = 207352860</center><h3 id="总结：已知n叉树的先序和后序遍历，求符合条件的n叉树的个数，解题策略为"><a href="#总结：已知n叉树的先序和后序遍历，求符合条件的n叉树的个数，解题策略为" class="headerlink" title="总结：已知n叉树的先序和后序遍历，求符合条件的n叉树的个数，解题策略为"></a>总结：已知n叉树的先序和后序遍历，求符合条件的n叉树的个数，解题策略为</h3><ul><li><p>设符合条件的n叉树的个数为sum，初值为1;</p></li><li><p>根据n叉树的先序遍历求出根结点，根结点的子树数为k（初值为0），n叉树结点个数为m；</p></li><li><p>找出先序遍历中根结点后一个结点和后序遍历中根结点前一个结点，如果这两个结点相同，则n叉树只有一个子树(k=1)，从树的形态上讲，这个子树可以是根结点的第1个子树或第2个子树……或第n个子树，因此共有C<sub>n</sub><sup>1</sup>种；</p></li><li><p>如果这两个结点不相同，则说明根结点存在多个子树；从后序遍历的第一个结点开始找与先序遍历中根结点后一个结点相同的结点，并记下位置t1，则后序遍历1~ t1之间的结点和先序遍历2~ t1+1之间的结点构成了根结点的第一个子树(k=1)；接着从后序遍历的第t1+1个结点开始找与先序遍历中第t1+2结点相同的结点，并记下位置t2，则后序遍历t1+1~ t2之间的结点和先序遍历t1+2~ t2+1之间的结点构成了根结点的第二个子树（k=2）；若t2+1&lt;m，则根结点还有其它子树，按上述方法重复查找，直到t2+1=m。则根结点的k个子树全部确定，其形状排列方式共有C<sub>n</sub><sup>k</sup>种。</p></li><li><p>若根结点的k个子树只有一个结点，则结束求解，否则对根结点的k个子树按本解题策略分别进行递归求解，求解其符合条件的子树的个数sum1、sum2、sum3……、sumk；则sum = C<sub>n</sub><sup>k</sup> * sum1 * sum2 * … * sumk </p></li></ul><p>最后，排列数的计算使用dp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; MAX; i++) &#123;<br>dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">1</span>][j];<br>&#125;<br>dp[i][i] = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3fffffff</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 25</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> vec vector<span class="hljs-string">&lt;ll&gt;</span></span><br><br><span class="hljs-type">int</span> dp[MAX][MAX];<span class="hljs-comment">//dp[i][j]:i个里面取j个</span><br><span class="hljs-type">int</span> n; string s1, s2;<br><br><span class="hljs-function">ll <span class="hljs-title">solve</span><span class="hljs-params">(string pre, string post)</span> </span>&#123;<br>ll sum = <span class="hljs-number">1</span>, num = <span class="hljs-number">0</span>; <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>, i;<br>pre.<span class="hljs-built_in">erase</span>(pre.<span class="hljs-built_in">begin</span>());<span class="hljs-comment">//忽略根节点</span><br>post.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">//忽略根节点</span><br><span class="hljs-keyword">while</span> (k &lt; pre.<span class="hljs-built_in">length</span>()) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; post.<span class="hljs-built_in">length</span>(); i++) &#123;<br><span class="hljs-keyword">if</span> (post[i] == pre[k]) &#123;<span class="hljs-comment">//前序后序相遇，找到了一颗子树</span><br>sum *= <span class="hljs-built_in">solve</span>(pre.<span class="hljs-built_in">substr</span>(k, i - k + <span class="hljs-number">1</span>), post.<span class="hljs-built_in">substr</span>(k, i - k + <span class="hljs-number">1</span>));<br>num++; k = i + <span class="hljs-number">1</span>;<span class="hljs-comment">//更新子树数目和下一个根节点的位置</span><br><span class="hljs-keyword">break</span>; <br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> sum * dp[n][num];<span class="hljs-comment">//他的子树的的子树的组合数，乘以他的子树的组合数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; MAX; i++) &#123;<br>dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">1</span>][j];<br>&#125;<br>dp[i][i] = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">while</span> (cin &gt;&gt; n &amp;&amp; n) &#123;<br>cin &gt;&gt; s1 &gt;&gt; s2;<br>cout &lt;&lt; <span class="hljs-built_in">solve</span>(s1, s2) &lt;&lt; endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>先序遍历</tag>
      
      <tag>中序遍历</tag>
      
      <tag>后序遍历</tag>
      
      <tag>二叉树</tag>
      
      <tag>dfs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Deepmind全能选手&quot;Gato&quot;</title>
    <link href="/2022/06/21/Deepmind%E5%85%A8%E8%83%BD%E9%80%89%E6%89%8BGato/"/>
    <url>/2022/06/21/Deepmind%E5%85%A8%E8%83%BD%E9%80%89%E6%89%8BGato/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote><p>在写文章、画图之后，AI 大模型现在又同时有了打游戏的能力。不禁在想，强AI还远吗？</p></blockquote><p>如果能使用统一的序列模型就能解决所有任务，就能解决很多不必要的麻烦。近日，受大规模语言建模的启发，Deepmind用类似的方法构造了一个通用智能体<strong>Gato</strong>，它具有多模态、多任务、多具身的特点。</p><p>既然是多任务，就需要涉及到不同类型的数据，如何将这些数据“一视同仁”地作为训练数据输入到模型中呢？为了统一处理多模态数据，Deepmind将所有数据序列化为一个扁平的token序列。在此表示中，Gato会根据上下文将token组合成动作、文字、像素等信息。</p><h2 id="训练细节"><a href="#训练细节" class="headerlink" title="训练细节"></a>训练细节</h2><p>在 Gato 的训练阶段，来自不同任务和模态的数据被序列化为扁平的 token 序列，由一个类似于大型语言模型的 transformer 神经网络进行 batch 和其他处理。由于损失被 masked，Gato 只预测动作和文本目标。<br><img src="/img/Gato/pic3.jpg" alt="训练流程"><br>在部署 Gato 时，提示（如演示）被 tokenised，形成了初始序列。接着，环境产生了首个观察结果，该结果也被 tokenised 并添加到序列中。Gato 以自回归的方式对动作向量进行采样，一次只采样一个 token。</p><p>一旦包含动作向量的所有 token 都被采样（由环境的动作规范确定），动作被解码并发送给环境，然后逐步产生新的观察结果。重复这一过程。Gato 模型始终在包含 1024 个 token 的上下文环境窗口内查看之前所有的观察结果和动作。‍下图展示了将 Gato 部署为控制策略（control policy）的流程。<br><img src="/img/Gato/pic4.jpg" alt="训练流程"></p><h2 id="训练难度"><a href="#训练难度" class="headerlink" title="训练难度"></a>训练难度</h2><p>相比有 1750 亿参数的 GPT-3，Gato 要小很多，只有约 12 亿个参数。而且，其建设基础非常简洁，只依赖于一个 Transformer 架构。</p><p>研究人员在将 Gato 与另外两个分别有 7900 万、3.64 亿参数模型的所有基准任务平均分数，进行比较后发现，对于等效的令牌计数，随着规模的增加，AI 性能会显著提高。更大的 Gato 模型可以使用更多数据进行训练，并可能更好地执行各种任务。</p><p>大概这是第一个CV、NLP、RL的结合体？</p><p>see you~</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
      <tag>多模态</tag>
      
      <tag>Deepmind</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三年的蛰伏，以及迟到了七年的FMVP</title>
    <link href="/2022/06/20/first-post/"/>
    <url>/2022/06/20/first-post/</url>
    
    <content type="html"><![CDATA[<p>2022年6月17日，波士顿花园终场哨声响起，勇士又一次捧起了奥布莱恩杯，值得一提的是2015年勇士夺冠也是在6月17日。 只不过这一次库里没有用力把篮球扔向天空，当年那群意气风发的小伙子，现在已经变成定海神针般的老将，他们成为了球队老大哥、成为了丈夫、成为了父亲。</p><span id="more"></span><h2 id="遗憾"><a href="#遗憾" class="headerlink" title="遗憾"></a>遗憾</h2><p>2015年6月17日，同样客场夺冠，同样4-2结束比赛，当宣布伊戈达拉为总决赛MVP的时候，库里依然激动地为队友欢呼。那时候我在想，没事，反正核心阵容都还年轻，薪资机构也很健康，未来有的是机会。<br>后来的故事大家都知道了，16年3-1被翻盘，17、18年杜兰特加盟勇士并两连FMVP，19年克莱、杜兰特、考辛斯、鲁尼接连伤退，20年库里报销、球队摆烂，21年克莱二次重伤、怀斯曼报销，库里独木难支，在附加赛遭遇两连败，连续两年无缘季后赛。。。</p><h2 id="重来"><a href="#重来" class="headerlink" title="重来"></a>重来</h2><p>曾经的防守大闸老的老，走的走，退役的退役，没办法，库里身为老大哥只能以身作则练好防守，不管是从态度上还是行动上。于是我们可以看到本赛季的库里很少有以前着急下手的坏习惯，轻型小前锋已经无法点名他了——曾经那个球场精灵渐渐成了重剑无锋的娃娃脸肌肉男。<br>本赛季勇士队取得了联盟第三的战绩，但是库里从赛季中期开始手感一直不佳。有人发问：是不是勇士的体系成就了库里，库里是不是吃了团队的红利？ 这一切质疑随着季后赛的到来都化为云烟。<br>季后赛首轮，面对防守称不上优秀的丹佛掘金，普尔格林等队员还能在进攻端惩戒对方。但是到了次轮与灰熊队的肉搏战，人们发现，寄予众望的普尔只能一头扎进人堆等待失误或者被封盖，防守大闸格林面对对方一堆肌肉跳跳男也显得有些无力，生死时刻，勇士队还是只能指望库里。关键时刻，库里一次次的杀入内线——用速度过掉或者顶开防守人。最终勇士有惊无险地淘汰灰熊（虽然有过55分惨案）。 西决，勇士干净利落地淘汰了077带领的独行侠，双方倒是和和睦睦，似乎都提前知道结果是什么。</p><h2 id="登顶"><a href="#登顶" class="headerlink" title="登顶"></a>登顶</h2><p>如果说分区比赛是库里和勇士队其他球员互相支持，那么总决赛的前四场比赛可以称得上是库里孤独carry的代表作。面对本赛季DPOY斯玛特，防守联盟第二的凯尔特人，库里在前四场场均轰下34分左右，有质有量。即使这样，勇士也只是取得了2-2的战绩。第四场，面临扳平或者1-3的场面，库里砍下43+10，里突外投，从此以后，”关键时刻掉链子”和库里再也无关。<br>G5、G6勇士一鼓作气全都拿下，库里也终于获得了属于自己的FMVP。G6最后有一幕打动了我，比赛时间还剩下一个多回合，库里已经去底线与戴尔库里拥抱致意，因为转播角度的原因，之前我只看到了库里的背影，然后库里转过身来手撑身子、头朝下颤抖着，我看了这么多年的库里，那一刻我以为他是笑的颤抖，可等他抬起头的那一刻，我看到了他的泪水。就像情绪会沿着网线传染，我的眼眶也已湿润，明明是一支与我无关的球队，明明是一名与我素不相识的球员，因为他们的团结，因为他的坚守，我也为他们感动。</p><h2 id="关于友谊"><a href="#关于友谊" class="headerlink" title="关于友谊"></a>关于友谊</h2><p>还有一点非常有趣，比赛的最后时刻又是伊戈达拉将球从凯尔特人队员手中要来，然后送给库里。为什么要说又？2015年总决赛G6最后一刻，库里激动的将球抛向天空，苦了伊戈达拉满场追球。这可能是伊戈达拉最后一场比赛了，曾经飞天入地的小AI，如今场均只能登场1、2分钟，当个吉祥物。从此以后，库里正式成为了勇士队中年龄最大的球员。</p><center>斯蒂芬，球拿好，以后的路自己走了！</center><p><img src="/img/%E6%9D%82%E8%B0%881/pic3.png"><br><img src="/img/%E6%9D%82%E8%B0%881/pic4.png"></p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>勇士</tag>
      
      <tag>篮球</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
